{"version":3,"sources":["turbopack:///[project]/node_modules/web-streams-polyfill/src/utils.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/helpers/miscellaneous.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/helpers/webidl.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/simple-queue.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/abstract-ops/internal-methods.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream/generic-reader.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/stub/number-isfinite.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/stub/math-trunc.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/basic.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/readable-stream.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream/default-reader.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/target/es2018/stub/async-iterator-prototype.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream/async-iterator.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/stub/number-isnan.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/abstract-ops/ecmascript.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/abstract-ops/miscellaneous.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/abstract-ops/queue-with-sizes.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/helpers/array-buffer-view.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/reader-options.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/abstract-ops/queuing-strategy.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/underlying-sink.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/writable-stream.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/abort-signal.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/writable-stream.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/globals.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/stub/dom-exception.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream/pipe.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream/default-controller.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream/tee.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream/from.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/underlying-source.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/iterator-options.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/pipe-options.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/readable-writable-pair.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/readable-stream.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy-init.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/byte-length-queuing-strategy.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/count-queuing-strategy.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/validators/transformer.ts","turbopack:///[project]/node_modules/web-streams-polyfill/src/lib/transform-stream.ts","turbopack:///[project]/node_modules/fetch-blob/streams.cjs","turbopack:///[project]/node_modules/fetch-blob/index.js","turbopack:///[project]/node_modules/fetch-blob/file.js","turbopack:///[project]/node_modules/formdata-polyfill/esm.min.js","turbopack:///[project]/node_modules/node-domexception/index.js","turbopack:///[project]/node_modules/fetch-blob/from.js"],"sourcesContent":["export function noop(): undefined {\n  return undefined;\n}\n","import { noop } from '../../utils';\nimport { AssertionError } from '../../stub/assert';\n\nexport function typeIsObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport const rethrowAssertionErrorRejection: (e: any) => void =\n  DEBUG ? e => {\n    // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n    // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n    // expect any errors, but assertion errors are always problematic.\n    if (e && e instanceof AssertionError) {\n      setTimeout(() => {\n        throw e;\n      }, 0);\n    }\n  } : noop;\n\nexport function setFunctionName(fn: Function, name: string): void {\n  try {\n    Object.defineProperty(fn, 'name', {\n      value: name,\n      configurable: true\n    });\n  } catch {\n    // This property is non-configurable in older browsers, so ignore if this throws.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n  }\n}\n","import { rethrowAssertionErrorRejection } from './miscellaneous';\nimport assert from '../../stub/assert';\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\n\n// https://webidl.spec.whatwg.org/#a-new-promise\nexport function newPromise<T>(executor: (\n  resolve: (value: T | PromiseLike<T>) => void,\n  reject: (reason?: any) => void\n) => void): Promise<T> {\n  return new originalPromise(executor);\n}\n\n// https://webidl.spec.whatwg.org/#a-promise-resolved-with\nexport function promiseResolvedWith<T>(value: T | PromiseLike<T>): Promise<T> {\n  return newPromise(resolve => resolve(value));\n}\n\n// https://webidl.spec.whatwg.org/#a-promise-rejected-with\nexport function promiseRejectedWith<T = never>(reason: any): Promise<T> {\n  return originalPromiseReject(reason);\n}\n\nexport function PerformPromiseThen<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n  // approximation.\n  return originalPromiseThen.call(promise, onFulfilled, onRejected) as Promise<TResult1 | TResult2>;\n}\n\n// Bluebird logs a warning when a promise is created within a fulfillment handler, but then isn't returned\n// from that handler. To prevent this, return null instead of void from all handlers.\n// http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it\nexport function uponPromise<T>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => null | PromiseLike<null>,\n  onRejected?: (reason: any) => null | PromiseLike<null>): void {\n  PerformPromiseThen(\n    PerformPromiseThen(promise, onFulfilled, onRejected),\n    undefined,\n    rethrowAssertionErrorRejection\n  );\n}\n\nexport function uponFulfillment<T>(promise: Promise<T>, onFulfilled: (value: T) => null | PromiseLike<null>): void {\n  uponPromise(promise, onFulfilled);\n}\n\nexport function uponRejection(promise: Promise<unknown>, onRejected: (reason: any) => null | PromiseLike<null>): void {\n  uponPromise(promise, undefined, onRejected);\n}\n\nexport function transformPromiseWith<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  fulfillmentHandler?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  rejectionHandler?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\n\nexport function setPromiseIsHandledToTrue(promise: Promise<unknown>): void {\n  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\n\nlet _queueMicrotask: (callback: () => void) => void = callback => {\n  if (typeof queueMicrotask === 'function') {\n    _queueMicrotask = queueMicrotask;\n  } else {\n    const resolvedPromise = promiseResolvedWith(undefined);\n    _queueMicrotask = cb => PerformPromiseThen(resolvedPromise, cb);\n  }\n  return _queueMicrotask(callback);\n};\n\nexport { _queueMicrotask as queueMicrotask };\n\nexport function reflectCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R, V: T, args: A): R {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexport function promiseCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R | PromiseLike<R>,\n                                                   V: T,\n                                                   args: A): Promise<R> {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return promiseResolvedWith(reflectCall(F, V, args));\n  } catch (value) {\n    return promiseRejectedWith(value);\n  }\n}\n","import assert from '../stub/assert';\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n\ninterface Node<T> {\n  _elements: T[];\n  _next: Node<T> | undefined;\n}\n\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nexport class SimpleQueue<T> {\n  private _front: Node<T>;\n  private _back: Node<T>;\n  private _cursor = 0;\n  private _size = 0;\n\n  constructor() {\n    // _front and _back are always defined.\n    this._front = {\n      _elements: [],\n      _next: undefined\n    };\n    this._back = this._front;\n    // The cursor is used to avoid calling Array.shift().\n    // It contains the index of the front element of the array inside the\n    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n    this._cursor = 0;\n    // When there is only one node, size === elements.length - cursor.\n    this._size = 0;\n  }\n\n  get length(): number {\n    return this._size;\n  }\n\n  // For exception safety, this method is structured in order:\n  // 1. Read state\n  // 2. Calculate required state mutations\n  // 3. Perform state mutations\n  push(element: T): void {\n    const oldBack = this._back;\n    let newBack = oldBack;\n    assert(oldBack._next === undefined);\n    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n      newBack = {\n        _elements: [],\n        _next: undefined\n      };\n    }\n\n    // push() is the mutation most likely to throw an exception, so it\n    // goes first.\n    oldBack._elements.push(element);\n    if (newBack !== oldBack) {\n      this._back = newBack;\n      oldBack._next = newBack;\n    }\n    ++this._size;\n  }\n\n  // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  // exception safety.\n  shift(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const oldFront = this._front;\n    let newFront = oldFront;\n    const oldCursor = this._cursor;\n    let newCursor = oldCursor + 1;\n\n    const elements = oldFront._elements;\n    const element = elements[oldCursor];\n\n    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n      assert(elements.length === QUEUE_MAX_ARRAY_SIZE);\n      assert(oldFront._next !== undefined);\n      newFront = oldFront._next!;\n      newCursor = 0;\n    }\n\n    // No mutations before this point.\n    --this._size;\n    this._cursor = newCursor;\n    if (oldFront !== newFront) {\n      this._front = newFront;\n    }\n\n    // Permit shifted element to be garbage collected.\n    elements[oldCursor] = undefined!;\n\n    return element;\n  }\n\n  // The tricky thing about forEach() is that it can be called\n  // re-entrantly. The queue may be mutated inside the callback. It is easy to\n  // see that push() within the callback has no negative effects since the end\n  // of the queue is checked for on every iteration. If shift() is called\n  // repeatedly within the callback then the next iteration may return an\n  // element that has been removed. In this case the callback will be called\n  // with undefined values until we either \"catch up\" with elements that still\n  // exist or reach the back of the queue.\n  forEach(callback: (element: T) => void): void {\n    let i = this._cursor;\n    let node = this._front;\n    let elements = node._elements;\n    while (i !== elements.length || node._next !== undefined) {\n      if (i === elements.length) {\n        assert(node._next !== undefined);\n        assert(i === QUEUE_MAX_ARRAY_SIZE);\n        node = node._next!;\n        elements = node._elements;\n        i = 0;\n        if (elements.length === 0) {\n          break;\n        }\n      }\n      callback(elements[i]);\n      ++i;\n    }\n  }\n\n  // Return the element that would be returned if shift() was called now,\n  // without modifying the queue.\n  peek(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const front = this._front;\n    const cursor = this._cursor;\n    return front._elements[cursor];\n  }\n}\n","export const AbortSteps = Symbol('[[AbortSteps]]');\nexport const ErrorSteps = Symbol('[[ErrorSteps]]');\nexport const CancelSteps = Symbol('[[CancelSteps]]');\nexport const PullSteps = Symbol('[[PullSteps]]');\nexport const ReleaseSteps = Symbol('[[ReleaseSteps]]');\n","import assert from '../../stub/assert';\nimport { ReadableStream, ReadableStreamCancel, type ReadableStreamReader } from '../readable-stream';\nimport { newPromise, setPromiseIsHandledToTrue } from '../helpers/webidl';\nimport { ReleaseSteps } from '../abstract-ops/internal-methods';\n\nexport function ReadableStreamReaderGenericInitialize<R>(reader: ReadableStreamReader<R>, stream: ReadableStream<R>) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nexport function ReadableStreamReaderGenericCancel(reader: ReadableStreamReader<any>, reason: any): Promise<undefined> {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nexport function ReadableStreamReaderGenericRelease(reader: ReadableStreamReader<any>) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  assert(stream._reader === reader);\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  }\n\n  stream._readableStreamController[ReleaseSteps]();\n\n  stream._reader = undefined;\n  reader._ownerReadableStream = undefined!;\n}\n\n// Helper functions for the readers.\n\nexport function readerLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nexport function defaultReaderClosedPromiseInitialize(reader: ReadableStreamReader<any>) {\n  reader._closedPromise = newPromise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nexport function defaultReaderClosedPromiseInitializeAsRejected(reader: ReadableStreamReader<any>, reason: any) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseReject(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseInitializeAsResolved(reader: ReadableStreamReader<any>) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseResolve(reader);\n}\n\nexport function defaultReaderClosedPromiseReject(reader: ReadableStreamReader<any>, reason: any) {\n  if (reader._closedPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(reader._closedPromise);\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nexport function defaultReaderClosedPromiseResetToRejected(reader: ReadableStreamReader<any>, reason: any) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseResolve(reader: ReadableStreamReader<any>) {\n  if (reader._closedPromise_resolve === undefined) {\n    return;\n  }\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n","/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite: typeof Number.isFinite = Number.isFinite || function (x) {\n  return typeof x === 'number' && isFinite(x);\n};\n\nexport default NumberIsFinite;\n","/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc: typeof Math.trunc = Math.trunc || function (v) {\n  return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\nexport default MathTrunc;\n","import NumberIsFinite from '../../stub/number-isfinite';\nimport MathTrunc from '../../stub/math-trunc';\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nexport function isDictionary(x: any): x is object | null {\n  return typeof x === 'object' || typeof x === 'function';\n}\n\nexport function assertDictionary(obj: unknown,\n                                 context: string): asserts obj is object | null | undefined {\n  if (obj !== undefined && !isDictionary(obj)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport type AnyFunction = (...args: any[]) => any;\n\n// https://heycam.github.io/webidl/#idl-callback-functions\nexport function assertFunction(x: unknown, context: string): asserts x is AnyFunction {\n  if (typeof x !== 'function') {\n    throw new TypeError(`${context} is not a function.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-object\nexport function isObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport function assertObject(x: unknown,\n                             context: string): asserts x is object {\n  if (!isObject(x)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport function assertRequiredArgument<T>(x: T | undefined,\n                                          position: number,\n                                          context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n  }\n}\n\nexport function assertRequiredField<T>(x: T | undefined,\n                                       field: string,\n                                       context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`${field} is required in '${context}'.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nexport function convertUnrestrictedDouble(value: unknown): number {\n  return Number(value);\n}\n\nfunction censorNegativeZero(x: number): number {\n  return x === 0 ? 0 : x;\n}\n\nfunction integerPart(x: number): number {\n  return censorNegativeZero(MathTrunc(x));\n}\n\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nexport function convertUnsignedLongLongWithEnforceRange(value: unknown, context: string): number {\n  const lowerBound = 0;\n  const upperBound = Number.MAX_SAFE_INTEGER;\n\n  let x = Number(value);\n  x = censorNegativeZero(x);\n\n  if (!NumberIsFinite(x)) {\n    throw new TypeError(`${context} is not a finite number`);\n  }\n\n  x = integerPart(x);\n\n  if (x < lowerBound || x > upperBound) {\n    throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n  }\n\n  if (!NumberIsFinite(x) || x === 0) {\n    return 0;\n  }\n\n  // TODO Use BigInt if supported?\n  // let xBigInt = BigInt(integerPart(x));\n  // xBigInt = BigInt.asUintN(64, xBigInt);\n  // return Number(xBigInt);\n\n  return x;\n}\n","import { IsReadableStream, ReadableStream } from '../readable-stream';\n\nexport function assertReadableStream(x: unknown, context: string): asserts x is ReadableStream {\n  if (!IsReadableStream(x)) {\n    throw new TypeError(`${context} is not a ReadableStream.`);\n  }\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, ReadableStream } from '../readable-stream';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { PullSteps } from '../abstract-ops/internal-methods';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\n\n/**\n * A result returned by {@link ReadableStreamDefaultReader.read}.\n *\n * @public\n */\nexport type ReadableStreamDefaultReadResult<T> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value?: undefined;\n}\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamDefaultReader<R>(stream: ReadableStream): ReadableStreamDefaultReader<R> {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadRequest<R>(stream: ReadableStream<R>,\n                                                readRequest: ReadRequest<R>): void {\n  assert(IsReadableStreamDefaultReader(stream._reader));\n  assert(stream._state === 'readable');\n\n  (stream._reader! as ReadableStreamDefaultReader<R>)._readRequests.push(readRequest);\n}\n\nexport function ReadableStreamFulfillReadRequest<R>(stream: ReadableStream<R>, chunk: R | undefined, done: boolean) {\n  const reader = stream._reader as ReadableStreamDefaultReader<R>;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift()!;\n  if (done) {\n    readRequest._closeSteps();\n  } else {\n    readRequest._chunkSteps(chunk!);\n  }\n}\n\nexport function ReadableStreamGetNumReadRequests<R>(stream: ReadableStream<R>): number {\n  return (stream._reader as ReadableStreamDefaultReader<R>)._readRequests.length;\n}\n\nexport function ReadableStreamHasDefaultReader(stream: ReadableStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamDefaultReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadRequest<R> {\n  _chunkSteps(chunk: R): void;\n\n  _closeSteps(): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamDefaultReader<R = any> {\n  /** @internal */\n  _ownerReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readRequests: SimpleQueue<ReadRequest<R>>;\n\n  constructor(stream: ReadableStream<R>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed,\n   * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamDefaultReaderRead(this, readRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamDefaultReader(this)) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    ReadableStreamDefaultReaderRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nsetFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\nsetFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamDefaultReader<R = any>(x: any): x is ReadableStreamDefaultReader<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultReader;\n}\n\nexport function ReadableStreamDefaultReaderRead<R>(reader: ReadableStreamDefaultReader<R>,\n                                                   readRequest: ReadRequest<R>): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    readRequest._closeSteps();\n  } else if (stream._state === 'errored') {\n    readRequest._errorSteps(stream._storedError);\n  } else {\n    assert(stream._state === 'readable');\n    stream._readableStreamController[PullSteps](readRequest as ReadRequest<any>);\n  }\n}\n\nexport function ReadableStreamDefaultReaderRelease(reader: ReadableStreamDefaultReader) {\n  ReadableStreamReaderGenericRelease(reader);\n  const e = new TypeError('Reader was released');\n  ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n}\n\nexport function ReadableStreamDefaultReaderErrorReadRequests(reader: ReadableStreamDefaultReader, e: any) {\n  const readRequests = reader._readRequests;\n  reader._readRequests = new SimpleQueue();\n  readRequests.forEach(readRequest => {\n    readRequest._errorSteps(e);\n  });\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n","/// <reference lib=\"es2018.asynciterable\" />\n\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const AsyncIteratorPrototype: AsyncIterable<any> =\n  Object.getPrototypeOf(Object.getPrototypeOf(async function* (): AsyncIterableIterator<any> {}).prototype);\n","/// <reference lib=\"es2018.asynciterable\" />\n\nimport { ReadableStream } from '../readable-stream';\nimport {\n  AcquireReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  type ReadableStreamDefaultReadResult,\n  type ReadRequest\n} from './default-reader';\nimport { ReadableStreamReaderGenericCancel, ReadableStreamReaderGenericRelease } from './generic-reader';\nimport assert from '../../stub/assert';\nimport { AsyncIteratorPrototype } from '@@target/stub/async-iterator-prototype';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  queueMicrotask,\n  transformPromiseWith\n} from '../helpers/webidl';\n\n/**\n * An async iterator returned by {@link ReadableStream.values}.\n *\n * @public\n */\nexport interface ReadableStreamAsyncIterator<R> extends AsyncIterableIterator<R> {\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nexport class ReadableStreamAsyncIteratorImpl<R> {\n  private readonly _reader: ReadableStreamDefaultReader<R>;\n  private readonly _preventCancel: boolean;\n  private _ongoingPromise: Promise<ReadableStreamDefaultReadResult<R>> | undefined = undefined;\n  private _isFinished = false;\n\n  constructor(reader: ReadableStreamDefaultReader<R>, preventCancel: boolean) {\n    this._reader = reader;\n    this._preventCancel = preventCancel;\n  }\n\n  next(): Promise<ReadableStreamDefaultReadResult<R>> {\n    const nextSteps = () => this._nextSteps();\n    this._ongoingPromise = this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n      nextSteps();\n    return this._ongoingPromise;\n  }\n\n  return(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    const returnSteps = () => this._returnSteps(value);\n    return this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n      returnSteps();\n  }\n\n  private _nextSteps(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value: undefined, done: true });\n    }\n\n    const reader = this._reader;\n    assert(reader._ownerReadableStream !== undefined);\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        this._ongoingPromise = undefined;\n        // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n        // FIXME Is this a bug in the specification, or in the test?\n        queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n      },\n      _closeSteps: () => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        resolvePromise({ value: undefined, done: true });\n      },\n      _errorSteps: reason => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        rejectPromise(reason);\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n    return promise;\n  }\n\n  private _returnSteps(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value, done: true });\n    }\n    this._isFinished = true;\n\n    const reader = this._reader;\n    assert(reader._ownerReadableStream !== undefined);\n    assert(reader._readRequests.length === 0);\n\n    if (!this._preventCancel) {\n      const result = ReadableStreamReaderGenericCancel(reader, value);\n      ReadableStreamReaderGenericRelease(reader);\n      return transformPromiseWith(result, () => ({ value, done: true }));\n    }\n\n    ReadableStreamReaderGenericRelease(reader);\n    return promiseResolvedWith({ value, done: true });\n  }\n}\n\ninterface ReadableStreamAsyncIteratorInstance<R> extends ReadableStreamAsyncIterator<R> {\n  /** @interal */\n  _asyncIteratorImpl: ReadableStreamAsyncIteratorImpl<R>;\n\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nconst ReadableStreamAsyncIteratorPrototype: ReadableStreamAsyncIteratorInstance<any> = {\n  next(this: ReadableStreamAsyncIteratorInstance<any>): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n    }\n    return this._asyncIteratorImpl.next();\n  },\n\n  return(this: ReadableStreamAsyncIteratorInstance<any>, value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n    }\n    return this._asyncIteratorImpl.return(value);\n  }\n} as any;\nObject.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamAsyncIterator<R>(stream: ReadableStream<R>,\n                                                      preventCancel: boolean): ReadableStreamAsyncIterator<R> {\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n  const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  const iterator: ReadableStreamAsyncIteratorInstance<R> = Object.create(ReadableStreamAsyncIteratorPrototype);\n  iterator._asyncIteratorImpl = impl;\n  return iterator;\n}\n\nfunction IsReadableStreamAsyncIterator<R = any>(x: any): x is ReadableStreamAsyncIterator<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n    return false;\n  }\n\n  try {\n    // noinspection SuspiciousTypeOfGuard\n    return (x as ReadableStreamAsyncIteratorInstance<any>)._asyncIteratorImpl instanceof\n      ReadableStreamAsyncIteratorImpl;\n  } catch {\n    return false;\n  }\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamAsyncIteratorBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n","/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN: typeof Number.isNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","import { reflectCall } from 'lib/helpers/webidl';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport assert from '../../stub/assert';\n\ndeclare global {\n  interface ArrayBuffer {\n    readonly detached: boolean;\n\n    transfer(): ArrayBuffer;\n  }\n\n  function structuredClone<T>(value: T, options: { transfer: ArrayBuffer[] }): T;\n}\n\nexport function CreateArrayFromList<T extends any[]>(elements: T): T {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice() as T;\n}\n\nexport function CopyDataBlockBytes(dest: ArrayBuffer,\n                                   destOffset: number,\n                                   src: ArrayBuffer,\n                                   srcOffset: number,\n                                   n: number) {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n\nexport let TransferArrayBuffer = (O: ArrayBuffer): ArrayBuffer => {\n  if (typeof O.transfer === 'function') {\n    TransferArrayBuffer = buffer => buffer.transfer();\n  } else if (typeof structuredClone === 'function') {\n    TransferArrayBuffer = buffer => structuredClone(buffer, { transfer: [buffer] });\n  } else {\n    // Not implemented correctly\n    TransferArrayBuffer = buffer => buffer;\n  }\n  return TransferArrayBuffer(O);\n};\n\nexport function CanTransferArrayBuffer(O: ArrayBuffer): boolean {\n  return !IsDetachedBuffer(O);\n}\n\nexport let IsDetachedBuffer = (O: ArrayBuffer): boolean => {\n  if (typeof O.detached === 'boolean') {\n    IsDetachedBuffer = buffer => buffer.detached;\n  } else {\n    // Not implemented correctly\n    IsDetachedBuffer = buffer => buffer.byteLength === 0;\n  }\n  return IsDetachedBuffer(O);\n};\n\nexport function ArrayBufferSlice(buffer: ArrayBuffer, begin: number, end: number): ArrayBuffer {\n  // ArrayBuffer.prototype.slice is not available on IE10\n  // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n  if (buffer.slice) {\n    return buffer.slice(begin, end);\n  }\n  const length = end - begin;\n  const slice = new ArrayBuffer(length);\n  CopyDataBlockBytes(slice, 0, buffer, begin, length);\n  return slice;\n}\n\nexport type MethodName<T> = {\n  [P in keyof T]: T[P] extends Function | undefined ? P : never;\n}[keyof T];\n\nexport function GetMethod<T, K extends MethodName<T>>(receiver: T, prop: K): T[K] | undefined {\n  const func = receiver[prop];\n  if (func === undefined || func === null) {\n    return undefined;\n  }\n  if (typeof func !== 'function') {\n    throw new TypeError(`${String(prop)} is not a function`);\n  }\n  return func;\n}\n\nexport interface SyncIteratorRecord<T> {\n  iterator: Iterator<T>,\n  nextMethod: Iterator<T>['next'],\n  done: boolean;\n}\n\nexport interface AsyncIteratorRecord<T> {\n  iterator: AsyncIterator<T>,\n  nextMethod: AsyncIterator<T>['next'],\n  done: boolean;\n}\n\nexport type SyncOrAsyncIteratorRecord<T> = SyncIteratorRecord<T> | AsyncIteratorRecord<T>;\n\nexport function CreateAsyncFromSyncIterator<T>(syncIteratorRecord: SyncIteratorRecord<T>): AsyncIteratorRecord<T> {\n  // Instead of re-implementing CreateAsyncFromSyncIterator and %AsyncFromSyncIteratorPrototype%,\n  // we use yield* inside an async generator function to achieve the same result.\n\n  // Wrap the sync iterator inside a sync iterable, so we can use it with yield*.\n  const syncIterable = {\n    [Symbol.iterator]: () => syncIteratorRecord.iterator\n  };\n  // Create an async generator function and immediately invoke it.\n  const asyncIterator = (async function* () {\n    return yield* syncIterable;\n  }());\n  // Return as an async iterator record.\n  const nextMethod = asyncIterator.next;\n  return { iterator: asyncIterator, nextMethod, done: false };\n}\n\n// Aligns with core-js/modules/es.symbol.async-iterator.js\nexport const SymbolAsyncIterator: (typeof Symbol)['asyncIterator'] =\n  Symbol.asyncIterator ??\n  Symbol.for?.('Symbol.asyncIterator') ??\n  '@@asyncIterator';\n\nexport type SyncOrAsyncIterable<T> = Iterable<T> | AsyncIterable<T>;\nexport type SyncOrAsyncIteratorMethod<T> = () => (Iterator<T> | AsyncIterator<T>);\n\nfunction GetIterator<T>(\n  obj: SyncOrAsyncIterable<T>,\n  hint: 'async',\n  method?: SyncOrAsyncIteratorMethod<T>\n): AsyncIteratorRecord<T>;\nfunction GetIterator<T>(\n  obj: Iterable<T>,\n  hint: 'sync',\n  method?: SyncOrAsyncIteratorMethod<T>\n): SyncIteratorRecord<T>;\nfunction GetIterator<T>(\n  obj: SyncOrAsyncIterable<T>,\n  hint = 'sync',\n  method?: SyncOrAsyncIteratorMethod<T>\n): SyncOrAsyncIteratorRecord<T> {\n  assert(hint === 'sync' || hint === 'async');\n  if (method === undefined) {\n    if (hint === 'async') {\n      method = GetMethod(obj as AsyncIterable<T>, SymbolAsyncIterator);\n      if (method === undefined) {\n        const syncMethod = GetMethod(obj as Iterable<T>, Symbol.iterator);\n        const syncIteratorRecord = GetIterator(obj as Iterable<T>, 'sync', syncMethod);\n        return CreateAsyncFromSyncIterator(syncIteratorRecord);\n      }\n    } else {\n      method = GetMethod(obj as Iterable<T>, Symbol.iterator);\n    }\n  }\n  if (method === undefined) {\n    throw new TypeError('The object is not iterable');\n  }\n  const iterator = reflectCall(method, obj, []);\n  if (!typeIsObject(iterator)) {\n    throw new TypeError('The iterator method must return an object');\n  }\n  const nextMethod = iterator.next;\n  return { iterator, nextMethod, done: false } as SyncOrAsyncIteratorRecord<T>;\n}\n\nexport { GetIterator };\n\nexport function IteratorNext<T>(iteratorRecord: AsyncIteratorRecord<T>): Promise<IteratorResult<T>> {\n  const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);\n  if (!typeIsObject(result)) {\n    throw new TypeError('The iterator.next() method must return an object');\n  }\n  return result;\n}\n\nexport function IteratorComplete<TReturn>(\n  iterResult: IteratorResult<unknown, TReturn>\n): iterResult is IteratorReturnResult<TReturn> {\n  assert(typeIsObject(iterResult));\n  return Boolean(iterResult.done);\n}\n\nexport function IteratorValue<T>(iterResult: IteratorYieldResult<T>): T {\n  assert(typeIsObject(iterResult));\n  return iterResult.value;\n}\n","import NumberIsNaN from '../../stub/number-isnan';\nimport { ArrayBufferSlice } from './ecmascript';\nimport type { NonShared } from '../helpers/array-buffer-view';\n\nexport function IsNonNegativeNumber(v: number): boolean {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (NumberIsNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function CloneAsUint8Array(O: NonShared<ArrayBufferView>): NonShared<Uint8Array> {\n  const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n  return new Uint8Array(buffer) as NonShared<Uint8Array>;\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsNonNegativeNumber } from './miscellaneous';\n\nexport interface QueueContainer<T> {\n  _queue: SimpleQueue<T>;\n  _queueTotalSize: number;\n}\n\nexport interface QueuePair<T> {\n  value: T;\n  size: number;\n}\n\nexport function DequeueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift()!;\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n}\n\nexport function EnqueueValueWithSize<T>(container: QueueContainer<QueuePair<T>>, value: T, size: number) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  if (!IsNonNegativeNumber(size) || size === Infinity) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n}\n\nexport function PeekQueueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.peek();\n  return pair.value;\n}\n\nexport function ResetQueue<T>(container: QueueContainer<T>) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = new SimpleQueue<T>();\n  container._queueTotalSize = 0;\n}\n","export type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array;\n\nexport type NonShared<T extends ArrayBufferView> = T & {\n  buffer: ArrayBuffer;\n}\n\nexport interface ArrayBufferViewConstructor<T extends ArrayBufferView = ArrayBufferView> {\n  new(buffer: ArrayBuffer, byteOffset: number, length?: number): T;\n\n  readonly prototype: T;\n}\n\nexport interface TypedArrayConstructor<T extends TypedArray = TypedArray> extends ArrayBufferViewConstructor<T> {\n  readonly BYTES_PER_ELEMENT: number;\n}\n\nexport type DataViewConstructor = ArrayBufferViewConstructor<DataView>;\n\nfunction isDataViewConstructor(ctor: Function): ctor is DataViewConstructor {\n  return ctor === DataView;\n}\n\nexport function isDataView(view: ArrayBufferView): view is DataView {\n  return isDataViewConstructor(view.constructor);\n}\n\nexport function arrayBufferViewElementSize<T extends ArrayBufferView>(ctor: ArrayBufferViewConstructor<T>): number {\n  if (isDataViewConstructor(ctor)) {\n    return 1;\n  }\n  return (ctor as unknown as TypedArrayConstructor).BYTES_PER_ELEMENT;\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  IsReadableStreamDefaultReader,\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  ReadableStreamHasDefaultReader,\n  type ReadRequest\n} from './default-reader';\nimport {\n  ReadableStreamAddReadIntoRequest,\n  ReadableStreamFulfillReadIntoRequest,\n  ReadableStreamGetNumReadIntoRequests,\n  ReadableStreamHasBYOBReader,\n  type ReadIntoRequest\n} from './byob-reader';\nimport NumberIsInteger from '../../stub/number-isinteger';\nimport {\n  IsReadableStreamLocked,\n  type ReadableByteStream,\n  ReadableStreamClose,\n  ReadableStreamError\n} from '../readable-stream';\nimport type { ValidatedUnderlyingByteSource } from './underlying-source';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport {\n  ArrayBufferSlice,\n  CanTransferArrayBuffer,\n  CopyDataBlockBytes,\n  IsDetachedBuffer,\n  TransferArrayBuffer\n} from '../abstract-ops/ecmascript';\nimport { CancelSteps, PullSteps, ReleaseSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\nimport { assertRequiredArgument, convertUnsignedLongLongWithEnforceRange } from '../validators/basic';\nimport {\n  type ArrayBufferViewConstructor,\n  arrayBufferViewElementSize,\n  type NonShared,\n  type TypedArrayConstructor\n} from '../helpers/array-buffer-view';\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nexport class ReadableStreamBYOBRequest {\n  /** @internal */\n  _associatedReadableByteStreamController!: ReadableByteStreamController;\n  /** @internal */\n  _view!: NonShared<ArrayBufferView> | null;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n   */\n  get view(): ArrayBufferView | null {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that `bytesWritten` bytes were written into\n   * {@link ReadableStreamBYOBRequest.view | view}, causing the result be surfaced to the consumer.\n   *\n   * After this method is called, {@link ReadableStreamBYOBRequest.view | view} will be transferred and no longer\n   * modifiable.\n   */\n  respond(bytesWritten: number): void;\n  respond(bytesWritten: number | undefined): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respond');\n    }\n    assertRequiredArgument(bytesWritten, 1, 'respond');\n    bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view!.buffer)) {\n      throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);\n    }\n\n    assert(this._view!.byteLength > 0);\n    assert(this._view!.buffer.byteLength > 0);\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that instead of writing into\n   * {@link ReadableStreamBYOBRequest.view | view}, the underlying byte source is providing a new `ArrayBufferView`,\n   * which will be given to the consumer of the readable byte stream.\n   *\n   * After this method is called, `view` will be transferred and no longer modifiable.\n   */\n  respondWithNewView(view: ArrayBufferView): void;\n  respondWithNewView(view: NonShared<ArrayBufferView>): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respondWithNewView');\n    }\n    assertRequiredArgument(view, 1, 'respondWithNewView');\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(view.buffer)) {\n      throw new TypeError('The given view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n  respond: { enumerable: true },\n  respondWithNewView: { enumerable: true },\n  view: { enumerable: true }\n});\nsetFunctionName(ReadableStreamBYOBRequest.prototype.respond, 'respond');\nsetFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, 'respondWithNewView');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBRequest',\n    configurable: true\n  });\n}\n\ninterface ByteQueueElement {\n  buffer: ArrayBuffer;\n  byteOffset: number;\n  byteLength: number;\n}\n\ntype PullIntoDescriptor<T extends NonShared<ArrayBufferView> = NonShared<ArrayBufferView>> =\n  DefaultPullIntoDescriptor\n  | BYOBPullIntoDescriptor<T>;\n\ninterface DefaultPullIntoDescriptor {\n  buffer: ArrayBuffer;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  minimumFill: number;\n  elementSize: number;\n  viewConstructor: TypedArrayConstructor<Uint8Array>;\n  readerType: 'default' | 'none';\n}\n\ninterface BYOBPullIntoDescriptor<T extends NonShared<ArrayBufferView> = NonShared<ArrayBufferView>> {\n  buffer: ArrayBuffer;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  minimumFill: number;\n  elementSize: number;\n  viewConstructor: ArrayBufferViewConstructor<T>;\n  readerType: 'byob' | 'none';\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableByteStreamController {\n  /** @internal */\n  _controlledReadableByteStream!: ReadableByteStream;\n  /** @internal */\n  _queue!: SimpleQueue<ByteQueueElement>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n  /** @internal */\n  _autoAllocateChunkSize: number | undefined;\n  /** @internal */\n  _byobRequest: ReadableStreamBYOBRequest | null;\n  /** @internal */\n  _pendingPullIntos!: SimpleQueue<PullIntoDescriptor>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the current BYOB pull request, or `null` if there isn't one.\n   */\n  get byobRequest(): ReadableStreamBYOBRequest | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    return ReadableByteStreamControllerGetBYOBRequest(this);\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk chunk in the controlled readable stream.\n   * The chunk has to be an `ArrayBufferView` instance, or else a `TypeError` will be thrown.\n   */\n  enqueue(chunk: ArrayBufferView): void;\n  enqueue(chunk: NonShared<ArrayBufferView>): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    assertRequiredArgument(chunk, 1, 'enqueue');\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('chunk must be an array buffer view');\n    }\n    if (chunk.byteLength === 0) {\n      throw new TypeError('chunk must have non-zero byteLength');\n    }\n    if (chunk.buffer.byteLength === 0) {\n      throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ReadableByteStreamControllerClearPendingPullIntos(this);\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<NonShared<Uint8Array>>): void {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream));\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n      return;\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer: ArrayBuffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        readRequest._errorSteps(bufferE);\n        return;\n      }\n\n      const pullIntoDescriptor: DefaultPullIntoDescriptor = {\n        buffer,\n        bufferByteLength: autoAllocateChunkSize,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        minimumFill: 1,\n        elementSize: 1,\n        viewConstructor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    ReadableStreamAddReadRequest(stream, readRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n  }\n\n  /** @internal */\n  [ReleaseSteps](): void {\n    if (this._pendingPullIntos.length > 0) {\n      const firstPullInto = this._pendingPullIntos.peek();\n      firstPullInto.readerType = 'none';\n\n      this._pendingPullIntos = new SimpleQueue();\n      this._pendingPullIntos.push(firstPullInto);\n    }\n  }\n}\n\nObject.defineProperties(ReadableByteStreamController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  byobRequest: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(ReadableByteStreamController.prototype.close, 'close');\nsetFunctionName(ReadableByteStreamController.prototype.enqueue, 'enqueue');\nsetFunctionName(ReadableByteStreamController.prototype.error, 'error');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {\n    value: 'ReadableByteStreamController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nexport function IsReadableByteStreamController(x: any): x is ReadableByteStreamController {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableByteStreamController;\n}\n\nfunction IsReadableStreamBYOBRequest(x: any): x is ReadableStreamBYOBRequest {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBRequest;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller: ReadableByteStreamController): void {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n\n      return null;\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n      return null;\n    }\n  );\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller: ReadableByteStreamController) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = new SimpleQueue();\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor<T extends NonShared<ArrayBufferView>>(\n  stream: ReadableByteStream,\n  pullIntoDescriptor: PullIntoDescriptor<T>\n) {\n  assert(stream._state !== 'errored');\n  assert(pullIntoDescriptor.readerType !== 'none');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView as unknown as NonShared<Uint8Array>, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor<T extends NonShared<ArrayBufferView>>(\n  pullIntoDescriptor: PullIntoDescriptor<T>\n): T {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.viewConstructor(\n    pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize) as T;\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller: ReadableByteStreamController,\n                                                         buffer: ArrayBuffer,\n                                                         byteOffset: number,\n                                                         byteLength: number) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller: ReadableByteStreamController,\n                                                               buffer: ArrayBuffer,\n                                                               byteOffset: number,\n                                                               byteLength: number) {\n  let clonedChunk;\n  try {\n    clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);\n  } catch (cloneE) {\n    ReadableByteStreamControllerError(controller, cloneE);\n    throw cloneE;\n  }\n  ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);\n}\n\nfunction ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller: ReadableByteStreamController,\n                                                                    firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.readerType === 'none');\n  if (firstDescriptor.bytesFilled > 0) {\n    ReadableByteStreamControllerEnqueueClonedChunkToQueue(\n      controller,\n      firstDescriptor.buffer,\n      firstDescriptor.byteOffset,\n      firstDescriptor.bytesFilled\n    );\n  }\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller: ReadableByteStreamController,\n                                                                     pullIntoDescriptor: PullIntoDescriptor) {\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  // of the queue, so the underlying source can keep filling it.\n  if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue.peek();\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (!ready) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller: ReadableByteStreamController,\n                                                                size: number,\n                                                                pullIntoDescriptor: PullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos.peek() === pullIntoDescriptor);\n  assert(controller._byobRequest === null);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller: ReadableByteStreamController) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller: ReadableByteStreamController) {\n  if (controller._byobRequest === null) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined!;\n  controller._byobRequest._view = null!;\n  controller._byobRequest = null;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller: ReadableByteStreamController) {\n  assert(!controller._closeRequested);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n    assert(pullIntoDescriptor.readerType !== 'none');\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller: ReadableByteStreamController) {\n  const reader = controller._controlledReadableByteStream._reader;\n  assert(IsReadableStreamDefaultReader(reader));\n  while (reader._readRequests.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n    const readRequest = reader._readRequests.shift();\n    ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n  }\n}\n\nexport function ReadableByteStreamControllerPullInto<T extends NonShared<ArrayBufferView>>(\n  controller: ReadableByteStreamController,\n  view: T,\n  min: number,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = controller._controlledReadableByteStream;\n\n  const ctor = view.constructor as ArrayBufferViewConstructor<T>;\n  const elementSize = arrayBufferViewElementSize(ctor);\n\n  const { byteOffset, byteLength } = view;\n\n  const minimumFill = min * elementSize;\n  assert(minimumFill >= elementSize && minimumFill <= byteLength);\n  assert(minimumFill % elementSize === 0);\n\n  let buffer: ArrayBuffer;\n  try {\n    buffer = TransferArrayBuffer(view.buffer);\n  } catch (e) {\n    readIntoRequest._errorSteps(e);\n    return;\n  }\n\n  const pullIntoDescriptor: BYOBPullIntoDescriptor<T> = {\n    buffer,\n    bufferByteLength: buffer.byteLength,\n    byteOffset,\n    byteLength,\n    bytesFilled: 0,\n    minimumFill,\n    elementSize,\n    viewConstructor: ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    return;\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    readIntoRequest._closeSteps(emptyView);\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      readIntoRequest._chunkSteps(filledView);\n      return;\n    }\n\n    if (controller._closeRequested) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      readIntoRequest._errorSteps(e);\n      return;\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  ReadableStreamAddReadIntoRequest<T>(stream, readIntoRequest);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller: ReadableByteStreamController,\n                                                          firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n\n  if (firstDescriptor.readerType === 'none') {\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n  }\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream)) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller: ReadableByteStreamController,\n                                                            bytesWritten: number,\n                                                            pullIntoDescriptor: PullIntoDescriptor) {\n  assert(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.readerType === 'none') {\n    ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    return;\n  }\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n    // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n    // of the queue, so the underlying source can keep filling it.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ReadableByteStreamControllerEnqueueClonedChunkToQueue(\n      controller,\n      pullIntoDescriptor.buffer,\n      end - remainderSize,\n      remainderSize\n    );\n  }\n\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller: ReadableByteStreamController, bytesWritten: number) {\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  assert(CanTransferArrayBuffer(firstDescriptor.buffer));\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  const state = controller._controlledReadableByteStream._state;\n  if (state === 'closed') {\n    assert(bytesWritten === 0);\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(state === 'readable');\n    assert(bytesWritten > 0);\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(\n  controller: ReadableByteStreamController\n): PullIntoDescriptor {\n  assert(controller._byobRequest === null);\n  const descriptor = controller._pendingPullIntos.shift()!;\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller: ReadableByteStreamController): boolean {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller: ReadableByteStreamController) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nexport function ReadableByteStreamControllerClose(controller: ReadableByteStreamController) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nexport function ReadableByteStreamControllerEnqueue(\n  controller: ReadableByteStreamController,\n  chunk: NonShared<ArrayBufferView>\n) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  const { buffer, byteOffset, byteLength } = chunk;\n  if (IsDetachedBuffer(buffer)) {\n    throw new TypeError('chunk\\'s buffer is detached and so cannot be enqueued');\n  }\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (IsDetachedBuffer(firstPendingPullInto.buffer)) {\n      throw new TypeError(\n        'The BYOB request\\'s buffer has been detached and so cannot be filled with an enqueued chunk'\n      );\n    }\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n    if (firstPendingPullInto.readerType === 'none') {\n      ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n    }\n  }\n\n  if (ReadableStreamHasDefaultReader(stream)) {\n    ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      assert(controller._pendingPullIntos.length === 0);\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n      if (controller._pendingPullIntos.length > 0) {\n        assert(controller._pendingPullIntos.peek().readerType === 'default');\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n      }\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView as NonShared<Uint8Array>, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream)) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(!IsReadableStreamLocked(stream));\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableByteStreamControllerError(controller: ReadableByteStreamController, e: any) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableByteStreamControllerFillReadRequestFromQueue(\n  controller: ReadableByteStreamController,\n  readRequest: ReadRequest<NonShared<Uint8Array>>\n) {\n  assert(controller._queueTotalSize > 0);\n\n  const entry = controller._queue.shift();\n  controller._queueTotalSize -= entry.byteLength;\n\n  ReadableByteStreamControllerHandleQueueDrain(controller);\n\n  const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n  readRequest._chunkSteps(view as NonShared<Uint8Array>);\n}\n\nexport function ReadableByteStreamControllerGetBYOBRequest(\n  controller: ReadableByteStreamController\n): ReadableStreamBYOBRequest | null {\n  if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const view = new Uint8Array(firstDescriptor.buffer,\n                                firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n    const byobRequest: ReadableStreamBYOBRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n    SetUpReadableStreamBYOBRequest(byobRequest, controller, view as NonShared<Uint8Array>);\n    controller._byobRequest = byobRequest;\n  }\n  return controller._byobRequest;\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller: ReadableByteStreamController): number | null {\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nexport function ReadableByteStreamControllerRespond(controller: ReadableByteStreamController, bytesWritten: number) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (bytesWritten === 0) {\n      throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n    }\n    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n      throw new RangeError('bytesWritten out of range');\n    }\n  }\n\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nexport function ReadableByteStreamControllerRespondWithNewView(controller: ReadableByteStreamController,\n                                                               view: NonShared<ArrayBufferView>) {\n  assert(controller._pendingPullIntos.length > 0);\n  assert(!IsDetachedBuffer(view.buffer));\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (view.byteLength !== 0) {\n      throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (view.byteLength === 0) {\n      throw new TypeError(\n        'The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream'\n      );\n    }\n  }\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n  if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n    throw new RangeError('The region specified by view is larger than byobRequest');\n  }\n\n  const viewByteLength = view.byteLength;\n  firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n  ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n}\n\nexport function SetUpReadableByteStreamController(stream: ReadableByteStream,\n                                                  controller: ReadableByteStreamController,\n                                                  startAlgorithm: () => void | PromiseLike<void>,\n                                                  pullAlgorithm: () => Promise<void>,\n                                                  cancelAlgorithm: (reason: any) => Promise<void>,\n                                                  highWaterMark: number,\n                                                  autoAllocateChunkSize: number | undefined) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._byobRequest = null;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = new SimpleQueue();\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n      return null;\n    },\n    r => {\n      ReadableByteStreamControllerError(controller, r);\n      return null;\n    }\n  );\n}\n\nexport function SetUpReadableByteStreamControllerFromUnderlyingSource(\n  stream: ReadableByteStream,\n  underlyingByteSource: ValidatedUnderlyingByteSource,\n  highWaterMark: number\n) {\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let pullAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingByteSource.start !== undefined) {\n    startAlgorithm = () => underlyingByteSource.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingByteSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingByteSource.pull!(controller);\n  } else {\n    pullAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingByteSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingByteSource.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize === 0) {\n    throw new TypeError('autoAllocateChunkSize must be greater than 0');\n  }\n\n  SetUpReadableByteStreamController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize\n  );\n}\n\nfunction SetUpReadableStreamBYOBRequest(request: ReadableStreamBYOBRequest,\n                                        controller: ReadableByteStreamController,\n                                        view: NonShared<ArrayBufferView>) {\n  assert(IsReadableByteStreamController(controller));\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view));\n  assert(!IsDetachedBuffer(view.buffer));\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n","import { assertDictionary, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ReadableStreamGetReaderOptions,\n  ValidatedReadableStreamBYOBReaderReadOptions\n} from '../readable-stream/reader-options';\n\nexport function convertReaderOptions(options: ReadableStreamGetReaderOptions | null | undefined,\n                                     context: string): ReadableStreamGetReaderOptions {\n  assertDictionary(options, context);\n  const mode = options?.mode;\n  return {\n    mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n  };\n}\n\nfunction convertReadableStreamReaderMode(mode: string, context: string): 'byob' {\n  mode = `${mode}`;\n  if (mode !== 'byob') {\n    throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n  }\n  return mode;\n}\n\nexport function convertByobReadOptions(\n  options: ReadableStreamBYOBReaderReadOptions | null | undefined,\n  context: string\n): ValidatedReadableStreamBYOBReaderReadOptions {\n  assertDictionary(options, context);\n  const min = options?.min ?? 1;\n  return {\n    min: convertUnsignedLongLongWithEnforceRange(\n      min,\n      `${context} has member 'min' that`\n    )\n  };\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, type ReadableByteStream, type ReadableStream } from '../readable-stream';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamController,\n  ReadableByteStreamControllerPullInto\n} from './byte-stream-controller';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\nimport { IsDetachedBuffer } from '../abstract-ops/ecmascript';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ValidatedReadableStreamBYOBReaderReadOptions\n} from './reader-options';\nimport { convertByobReadOptions } from '../validators/reader-options';\nimport { isDataView, type NonShared, type TypedArray } from '../helpers/array-buffer-view';\n\n/**\n * A result returned by {@link ReadableStreamBYOBReader.read}.\n *\n * @public\n */\nexport type ReadableStreamBYOBReadResult<T extends ArrayBufferView> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value: T | undefined;\n};\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamBYOBReader(stream: ReadableByteStream): ReadableStreamBYOBReader {\n  return new ReadableStreamBYOBReader(stream as ReadableStream<Uint8Array>);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadIntoRequest<T extends NonShared<ArrayBufferView>>(\n  stream: ReadableByteStream,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  assert(IsReadableStreamBYOBReader(stream._reader));\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  (stream._reader! as ReadableStreamBYOBReader)._readIntoRequests.push(readIntoRequest);\n}\n\nexport function ReadableStreamFulfillReadIntoRequest(stream: ReadableByteStream,\n                                                     chunk: ArrayBufferView,\n                                                     done: boolean) {\n  const reader = stream._reader as ReadableStreamBYOBReader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift()!;\n  if (done) {\n    readIntoRequest._closeSteps(chunk);\n  } else {\n    readIntoRequest._chunkSteps(chunk);\n  }\n}\n\nexport function ReadableStreamGetNumReadIntoRequests(stream: ReadableByteStream): number {\n  return (stream._reader as ReadableStreamBYOBReader)._readIntoRequests.length;\n}\n\nexport function ReadableStreamHasBYOBReader(stream: ReadableByteStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamBYOBReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadIntoRequest<T extends NonShared<ArrayBufferView>> {\n  _chunkSteps(chunk: T): void;\n\n  _closeSteps(chunk: T | undefined): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamBYOBReader {\n  /** @internal */\n  _ownerReadableStream!: ReadableByteStream;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readIntoRequests: SimpleQueue<ReadIntoRequest<any>>;\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    if (!IsReadableByteStreamController(stream._readableStreamController)) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n        'source');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Attempts to reads bytes into view, and returns a promise resolved with the result.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read<T extends ArrayBufferView>(\n    view: T,\n    options?: ReadableStreamBYOBReaderReadOptions\n  ): Promise<ReadableStreamBYOBReadResult<T>>;\n  read<T extends NonShared<ArrayBufferView>>(\n    view: T,\n    rawOptions: ReadableStreamBYOBReaderReadOptions | null | undefined = {}\n  ): Promise<ReadableStreamBYOBReadResult<T>> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('read'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n    }\n    if (view.byteLength === 0) {\n      return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n    }\n    if (view.buffer.byteLength === 0) {\n      return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n    }\n    if (IsDetachedBuffer(view.buffer)) {\n      return promiseRejectedWith(new TypeError('view\\'s buffer has been detached'));\n    }\n\n    let options: ValidatedReadableStreamBYOBReaderReadOptions;\n    try {\n      options = convertByobReadOptions(rawOptions, 'options');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const min = options.min;\n    if (min === 0) {\n      return promiseRejectedWith(new TypeError('options.min must be greater than 0'));\n    }\n    if (!isDataView(view)) {\n      if (min > (view as unknown as TypedArray).length) {\n        return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\\'s length'));\n      }\n    } else if (min > view.byteLength) {\n      return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\\'s byteLength'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamBYOBReadResult<T>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamBYOBReadResult<T>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readIntoRequest: ReadIntoRequest<T> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    ReadableStreamBYOBReaderRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nsetFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\nsetFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamBYOBReader(x: any): x is ReadableStreamBYOBReader {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBReader;\n}\n\nexport function ReadableStreamBYOBReaderRead<T extends NonShared<ArrayBufferView>>(\n  reader: ReadableStreamBYOBReader,\n  view: T,\n  min: number,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    readIntoRequest._errorSteps(stream._storedError);\n  } else {\n    ReadableByteStreamControllerPullInto(\n      stream._readableStreamController as ReadableByteStreamController,\n      view,\n      min,\n      readIntoRequest\n    );\n  }\n}\n\nexport function ReadableStreamBYOBReaderRelease(reader: ReadableStreamBYOBReader) {\n  ReadableStreamReaderGenericRelease(reader);\n  const e = new TypeError('Reader was released');\n  ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n}\n\nexport function ReadableStreamBYOBReaderErrorReadIntoRequests(reader: ReadableStreamBYOBReader, e: any) {\n  const readIntoRequests = reader._readIntoRequests;\n  reader._readIntoRequests = new SimpleQueue();\n  readIntoRequests.forEach(readIntoRequest => {\n    readIntoRequest._errorSteps(e);\n  });\n}\n\n// Helper functions for the ReadableStreamBYOBReader.\n\nfunction byobReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n","import type { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport NumberIsNaN from '../../stub/number-isnan';\n\nexport function ExtractHighWaterMark(strategy: QueuingStrategy, defaultHWM: number): number {\n  const { highWaterMark } = strategy;\n\n  if (highWaterMark === undefined) {\n    return defaultHWM;\n  }\n\n  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('Invalid highWaterMark');\n  }\n\n  return highWaterMark;\n}\n\nexport function ExtractSizeAlgorithm<T>(strategy: QueuingStrategy<T>): QueuingStrategySizeCallback<T> {\n  const { size } = strategy;\n\n  if (!size) {\n    return () => 1;\n  }\n\n  return size;\n}\n","import type { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport { assertDictionary, assertFunction, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategy<T>(init: QueuingStrategy<T> | null | undefined,\n                                          context: string): QueuingStrategy<T> {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  const size = init?.size;\n  return {\n    highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n    size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n  };\n}\n\nfunction convertQueuingStrategySize<T>(fn: QueuingStrategySizeCallback<T>,\n                                       context: string): QueuingStrategySizeCallback<T> {\n  assertFunction(fn, context);\n  return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n","import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport type {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from '../writable-stream/underlying-sink';\nimport { WritableStreamDefaultController } from '../writable-stream';\n\nexport function convertUnderlyingSink<W>(original: UnderlyingSink<W> | null,\n                                         context: string): ValidatedUnderlyingSink<W> {\n  assertDictionary(original, context);\n  const abort = original?.abort;\n  const close = original?.close;\n  const start = original?.start;\n  const type = original?.type;\n  const write = original?.write;\n  return {\n    abort: abort === undefined ?\n      undefined :\n      convertUnderlyingSinkAbortCallback(abort, original!, `${context} has member 'abort' that`),\n    close: close === undefined ?\n      undefined :\n      convertUnderlyingSinkCloseCallback(close, original!, `${context} has member 'close' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSinkStartCallback(start, original!, `${context} has member 'start' that`),\n    write: write === undefined ?\n      undefined :\n      convertUnderlyingSinkWriteCallback(write, original!, `${context} has member 'write' that`),\n    type\n  };\n}\n\nfunction convertUnderlyingSinkAbortCallback(\n  fn: UnderlyingSinkAbortCallback,\n  original: UnderlyingSink,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSinkCloseCallback(\n  fn: UnderlyingSinkCloseCallback,\n  original: UnderlyingSink,\n  context: string\n): () => Promise<void> {\n  assertFunction(fn, context);\n  return () => promiseCall(fn, original, []);\n}\n\nfunction convertUnderlyingSinkStartCallback(\n  fn: UnderlyingSinkStartCallback,\n  original: UnderlyingSink,\n  context: string\n): UnderlyingSinkStartCallback {\n  assertFunction(fn, context);\n  return (controller: WritableStreamDefaultController) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSinkWriteCallback<W>(\n  fn: UnderlyingSinkWriteCallback<W>,\n  original: UnderlyingSink<W>,\n  context: string\n): (chunk: W, controller: WritableStreamDefaultController) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: W, controller: WritableStreamDefaultController) => promiseCall(fn, original, [chunk, controller]);\n}\n","import { IsWritableStream, WritableStream } from '../writable-stream';\n\nexport function assertWritableStream(x: unknown, context: string): asserts x is WritableStream {\n  if (!IsWritableStream(x)) {\n    throw new TypeError(`${context} is not a WritableStream.`);\n  }\n}\n","/**\n * A signal object that allows you to communicate with a request and abort it if required\n * via its associated `AbortController` object.\n *\n * @remarks\n *   This interface is compatible with the `AbortSignal` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @public\n */\nexport interface AbortSignal {\n  /**\n   * Whether the request is aborted.\n   */\n  readonly aborted: boolean;\n\n  /**\n   * If aborted, returns the reason for aborting.\n   */\n  readonly reason?: any;\n\n  /**\n   * Add an event listener to be triggered when this signal becomes aborted.\n   */\n  addEventListener(type: 'abort', listener: () => void): void;\n\n  /**\n   * Remove an event listener that was previously added with {@link AbortSignal.addEventListener}.\n   */\n  removeEventListener(type: 'abort', listener: () => void): void;\n}\n\nexport function isAbortSignal(value: unknown): value is AbortSignal {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  try {\n    return typeof (value as AbortSignal).aborted === 'boolean';\n  } catch {\n    // AbortSignal.prototype.aborted throws if its brand check fails\n    return false;\n  }\n}\n\n/**\n * A controller object that allows you to abort an `AbortSignal` when desired.\n *\n * @remarks\n *   This interface is compatible with the `AbortController` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @internal\n */\nexport interface AbortController {\n  readonly signal: AbortSignal;\n\n  abort(reason?: any): void;\n}\n\ninterface AbortControllerConstructor {\n  new(): AbortController;\n}\n\nconst supportsAbortController = typeof (AbortController as any) === 'function';\n\n/**\n * Construct a new AbortController, if supported by the platform.\n *\n * @internal\n */\nexport function createAbortController(): AbortController | undefined {\n  if (supportsAbortController) {\n    return new (AbortController as AbortControllerConstructor)();\n  }\n  return undefined;\n}\n","import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponPromise\n} from './helpers/webidl';\nimport {\n  DequeueValue,\n  EnqueueValueWithSize,\n  PeekQueueValue,\n  type QueuePair,\n  ResetQueue\n} from './abstract-ops/queue-with-sizes';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { SimpleQueue } from './simple-queue';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { AbortSteps, ErrorSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport type {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from './writable-stream/underlying-sink';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertUnderlyingSink } from './validators/underlying-sink';\nimport { assertWritableStream } from './validators/writable-stream';\nimport { type AbortController, type AbortSignal, createAbortController } from './abort-signal';\n\ntype WritableStreamState = 'writable' | 'closed' | 'erroring' | 'errored';\n\ninterface WriteOrCloseRequest {\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n}\n\ntype WriteRequest = WriteOrCloseRequest;\ntype CloseRequest = WriteOrCloseRequest;\n\ninterface PendingAbortRequest {\n  _promise: Promise<undefined>;\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n  _reason: any;\n  _wasAlreadyErroring: boolean;\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream<W = any> {\n  /** @internal */\n  _state!: WritableStreamState;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _writer: WritableStreamDefaultWriter<W> | undefined;\n  /** @internal */\n  _writableStreamController!: WritableStreamDefaultController<W>;\n  /** @internal */\n  _writeRequests!: SimpleQueue<WriteRequest>;\n  /** @internal */\n  _inFlightWriteRequest: WriteRequest | undefined;\n  /** @internal */\n  _closeRequest: CloseRequest | undefined;\n  /** @internal */\n  _inFlightCloseRequest: CloseRequest | undefined;\n  /** @internal */\n  _pendingAbortRequest: PendingAbortRequest | undefined;\n  /** @internal */\n  _backpressure!: boolean;\n\n  constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);\n  constructor(rawUnderlyingSink: UnderlyingSink<W> | null | undefined = {},\n              rawStrategy: QueuingStrategy<W> | null | undefined = {}) {\n    if (rawUnderlyingSink === undefined) {\n      rawUnderlyingSink = null;\n    } else {\n      assertObject(rawUnderlyingSink, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n\n    InitializeWritableStream(this);\n\n    const type = underlyingSink.type;\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n    const highWaterMark = ExtractHighWaterMark(strategy, 1);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  /**\n   * Returns whether or not the writable stream is locked to a writer.\n   */\n  get locked(): boolean {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  /**\n   * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n   * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n   * mechanism of the underlying sink.\n   *\n   * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n   * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n   * the stream) if the stream is currently locked.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  /**\n   * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n   * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n   *\n   * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n   * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n   * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n   */\n  close() {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('close'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamClose(this);\n  }\n\n  /**\n   * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n   * is locked, no other writer can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n   * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n   * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n   */\n  getWriter(): WritableStreamDefaultWriter<W> {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nObject.defineProperties(WritableStream.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  getWriter: { enumerable: true },\n  locked: { enumerable: true }\n});\nsetFunctionName(WritableStream.prototype.abort, 'abort');\nsetFunctionName(WritableStream.prototype.close, 'close');\nsetFunctionName(WritableStream.prototype.getWriter, 'getWriter');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {\n    value: 'WritableStream',\n    configurable: true\n  });\n}\n\nexport {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\nexport type {\n  UnderlyingSink,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkAbortCallback\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter<W>(stream: WritableStream<W>): WritableStreamDefaultWriter<W> {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream<W>(startAlgorithm: () => void | PromiseLike<void>,\n                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                 closeAlgorithm: () => Promise<void>,\n                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                 highWaterMark = 1,\n                                 sizeAlgorithm: QueuingStrategySizeCallback<W> = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: WritableStream<W> = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller: WritableStreamDefaultController<W> = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream<W>(stream: WritableStream<W>) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined!;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = new SimpleQueue();\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x: unknown): x is WritableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return x instanceof WritableStream;\n}\n\nfunction IsWritableStreamLocked(stream: WritableStream): boolean {\n  assert(IsWritableStream(stream));\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream: WritableStream, reason: any): Promise<undefined> {\n  if (stream._state === 'closed' || stream._state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  stream._writableStreamController._abortReason = reason;\n  stream._writableStreamController._abortController?.abort(reason);\n\n  // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n  // but it doesn't know that signaling abort runs author code that might have changed the state.\n  // Widen the type again by casting to WritableStreamState.\n  const state = stream._state as WritableStreamState;\n\n  if (state === 'closed' || state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _promise: undefined!,\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest!._promise = promise;\n\n  if (!wasAlreadyErroring) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\nfunction WritableStreamClose(stream: WritableStream<any>): Promise<undefined> {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return promiseRejectedWith(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const closeRequest: CloseRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  const writer = stream._writer;\n  if (writer !== undefined && stream._backpressure && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream: WritableStream): Promise<undefined> {\n  assert(IsWritableStreamLocked(stream));\n  assert(stream._state === 'writable');\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const writeRequest: WriteRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream: WritableStream, error: any) {\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream: WritableStream, reason: any) {\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream: WritableStream) {\n  assert(stream._state === 'erroring');\n  assert(!WritableStreamHasOperationMarkedInFlight(stream));\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  stream._writeRequests.forEach(writeRequest => {\n    writeRequest._reject(storedError);\n  });\n  stream._writeRequests = new SimpleQueue();\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  uponPromise(\n    promise,\n    () => {\n      abortRequest._resolve();\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      return null;\n    },\n    (reason: any) => {\n      abortRequest._reject(reason);\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      return null;\n    });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream: WritableStream): boolean {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream: WritableStream): boolean {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream: WritableStream) {\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream: WritableStream, backpressure: boolean) {\n  assert(stream._state === 'writable');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(!backpressure);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nexport class WritableStreamDefaultWriter<W = any> {\n  /** @internal */\n  _ownerWritableStream: WritableStream<W>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _closedPromiseState!: 'pending' | 'resolved' | 'rejected';\n  /** @internal */\n  _readyPromise!: Promise<undefined>;\n  /** @internal */\n  _readyPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _readyPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readyPromiseState!: 'pending' | 'fulfilled' | 'rejected';\n\n  constructor(stream: WritableStream<W>) {\n    assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n    assertWritableStream(stream, 'First parameter');\n\n    if (IsWritableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n    }\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the writer’s lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.\n   * A producer can use this information to determine the right amount of data to write.\n   *\n   * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n   * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n   * the writer’s lock is released.\n   */\n  get desiredSize(): number | null {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions\n   * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n   * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n   *\n   * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become\n   * rejected.\n   */\n  get ready(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n   */\n  close(): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  /**\n   * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n   * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n   * now on; otherwise, the writer will appear closed.\n   *\n   * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   * other producers from writing in an interleaved manner.\n   */\n  releaseLock(): void {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  /**\n   * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n   * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n   * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n   * errored before the writing process is initiated.\n   *\n   * Note that what \"success\" means is up to the underlying sink; it might indicate simply that the chunk has been\n   * accepted, and not necessarily that it is safely saved to its ultimate destination.\n   */\n  write(chunk: W): Promise<void>;\n  write(chunk: W = undefined!): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  releaseLock: { enumerable: true },\n  write: { enumerable: true },\n  closed: { enumerable: true },\n  desiredSize: { enumerable: true },\n  ready: { enumerable: true }\n});\nsetFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\nsetFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\nsetFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\nsetFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultWriter',\n    configurable: true\n  });\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter<W = any>(x: any): x is WritableStreamDefaultWriter<W> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultWriter;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer: WritableStreamDefaultWriter, reason: any) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamClose(stream);\n}\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer: WritableStreamDefaultWriter): number | null {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer: WritableStreamDefaultWriter) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    `Writer was released and can no longer be used to monitor the stream's closedness`);\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined!;\n}\n\nfunction WritableStreamDefaultWriterWrite<W>(writer: WritableStreamDefaultWriter<W>, chunk: W): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return promiseRejectedWith(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nconst closeSentinel: unique symbol = {} as any;\n\ntype QueueRecord<W> = W | typeof closeSentinel;\n\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nexport class WritableStreamDefaultController<W = any> {\n  /** @internal */\n  _controlledWritableStream!: WritableStream<W>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<QueueRecord<W>>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _abortReason: any;\n  /** @internal */\n  _abortController: AbortController | undefined;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<W>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _writeAlgorithm!: (chunk: W) => Promise<void>;\n  /** @internal */\n  _closeAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _abortAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n   *\n   * @deprecated\n   *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n   *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n   */\n  get abortReason(): any {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('abortReason');\n    }\n    return this._abortReason;\n  }\n\n  /**\n   * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n   */\n  get signal(): AbortSignal {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('signal');\n    }\n    if (this._abortController === undefined) {\n      // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n      // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n      // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n      throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n    }\n    return this._abortController.signal;\n  }\n\n  /**\n   * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n   *\n   * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n   * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n   * normal lifecycle of interactions with the underlying sink.\n   */\n  error(e: any = undefined): void {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [AbortSteps](reason: any): Promise<void> {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n  abortReason: { enumerable: true },\n  signal: { enumerable: true },\n  error: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x: any): x is WritableStreamDefaultController<any> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultController;\n}\n\nfunction SetUpWritableStreamDefaultController<W>(stream: WritableStream<W>,\n                                                 controller: WritableStreamDefaultController<W>,\n                                                 startAlgorithm: () => void | PromiseLike<void>,\n                                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                                 closeAlgorithm: () => Promise<void>,\n                                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                                 highWaterMark: number,\n                                                 sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  assert(IsWritableStream(stream));\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._abortReason = undefined;\n  controller._abortController = createAbortController();\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = promiseResolvedWith(startResult);\n  uponPromise(\n    startPromise,\n    () => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      return null;\n    },\n    r => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDealWithRejection(stream, r);\n      return null;\n    }\n  );\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink<W>(stream: WritableStream<W>,\n                                                                   underlyingSink: ValidatedUnderlyingSink<W>,\n                                                                   highWaterMark: number,\n                                                                   sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let writeAlgorithm: (chunk: W) => Promise<void>;\n  let closeAlgorithm: () => Promise<void>;\n  let abortAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingSink.start !== undefined) {\n    startAlgorithm = () => underlyingSink.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingSink.write !== undefined) {\n    writeAlgorithm = chunk => underlyingSink.write!(chunk, controller);\n  } else {\n    writeAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSink.close !== undefined) {\n    closeAlgorithm = () => underlyingSink.close!();\n  } else {\n    closeAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSink.abort !== undefined) {\n    abortAlgorithm = reason => underlyingSink.abort!(reason);\n  } else {\n    abortAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpWritableStreamDefaultController(\n    stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller: WritableStreamDefaultController<any>) {\n  controller._writeAlgorithm = undefined!;\n  controller._closeAlgorithm = undefined!;\n  controller._abortAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\nfunction WritableStreamDefaultControllerClose<W>(controller: WritableStreamDefaultController<W>) {\n  EnqueueValueWithSize(controller, closeSentinel, 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize<W>(controller: WritableStreamDefaultController<W>,\n                                                        chunk: W): number {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller: WritableStreamDefaultController<any>): number {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite<W>(controller: WritableStreamDefaultController<W>,\n                                                 chunk: W,\n                                                 chunkSize: number) {\n  try {\n    EnqueueValueWithSize(controller, chunk, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded<W>(controller: WritableStreamDefaultController<W>) {\n  const stream = controller._controlledWritableStream;\n\n  if (!controller._started) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  assert(state !== 'closed' && state !== 'errored');\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const value = PeekQueueValue(controller);\n  if (value === closeSentinel) {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, value);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller: WritableStreamDefaultController<any>, error: any) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller: WritableStreamDefaultController<any>) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  uponPromise(\n    sinkClosePromise,\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n      return null;\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n      return null;\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerProcessWrite<W>(controller: WritableStreamDefaultController<W>, chunk: W) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  uponPromise(\n    sinkWritePromise,\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      return null;\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n      return null;\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller: WritableStreamDefaultController<any>): boolean {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller: WritableStreamDefaultController<any>, error: any) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n}\n\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._closedPromise = newPromise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseReject(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseResolve(writer);\n}\n\nfunction defaultWriterClosedPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._closedPromise_reject === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  setPromiseIsHandledToTrue(writer._closedPromise);\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._closedPromise_resolve === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._readyPromise = newPromise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseReject(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseResolve(writer);\n}\n\nfunction defaultWriterReadyPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._readyPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(writer._readyPromise);\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer: WritableStreamDefaultWriter) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitialize(writer);\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._readyPromise_resolve === undefined) {\n    return;\n  }\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n","/// <reference lib=\"dom\" />\n\nfunction getGlobals(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","/// <reference types=\"node\" />\nimport { globals } from '../globals';\nimport { setFunctionName } from '../lib/helpers/miscellaneous';\n\ninterface DOMException extends Error {\n  name: string;\n  message: string;\n}\n\ntype DOMExceptionConstructor = new (message?: string, name?: string) => DOMException;\n\nfunction isDOMExceptionConstructor(ctor: unknown): ctor is DOMExceptionConstructor {\n  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n    return false;\n  }\n  if ((ctor as DOMExceptionConstructor).name !== 'DOMException') {\n    return false;\n  }\n  try {\n    new (ctor as DOMExceptionConstructor)();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Support:\n * - Web browsers\n * - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)\n */\nfunction getFromGlobal(): DOMExceptionConstructor | undefined {\n  const ctor = globals?.DOMException;\n  return isDOMExceptionConstructor(ctor) ? ctor : undefined;\n}\n\n/**\n * Support:\n * - All platforms\n */\nfunction createPolyfill(): DOMExceptionConstructor {\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  const ctor = function DOMException(this: DOMException, message?: string, name?: string) {\n    this.message = message || '';\n    this.name = name || 'Error';\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  } as any;\n  setFunctionName(ctor, 'DOMException');\n  ctor.prototype = Object.create(Error.prototype);\n  Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n  return ctor;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nconst DOMException: DOMExceptionConstructor = getFromGlobal() || createPolyfill();\n\nexport { DOMException };\n","import { IsReadableStream, IsReadableStreamLocked, ReadableStream, ReadableStreamCancel } from '../readable-stream';\nimport { AcquireReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireWritableStreamDefaultWriter,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamCloseQueuedOrInFlight,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite\n} from '../writable-stream';\nimport assert from '../../stub/assert';\nimport {\n  newPromise,\n  PerformPromiseThen,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponFulfillment,\n  uponPromise,\n  uponRejection\n} from '../helpers/webidl';\nimport { noop } from '../../utils';\nimport { type AbortSignal, isAbortSignal } from '../abort-signal';\nimport { DOMException } from '../../stub/dom-exception';\n\nexport function ReadableStreamPipeTo<T>(source: ReadableStream<T>,\n                                        dest: WritableStream<T>,\n                                        preventClose: boolean,\n                                        preventAbort: boolean,\n                                        preventCancel: boolean,\n                                        signal: AbortSignal | undefined): Promise<undefined> {\n  assert(IsReadableStream(source));\n  assert(IsWritableStream(dest));\n  assert(typeof preventClose === 'boolean');\n  assert(typeof preventAbort === 'boolean');\n  assert(typeof preventCancel === 'boolean');\n  assert(signal === undefined || isAbortSignal(signal));\n  assert(!IsReadableStreamLocked(source));\n  assert(!IsWritableStreamLocked(dest));\n\n  const reader = AcquireReadableStreamDefaultReader<T>(source);\n  const writer = AcquireWritableStreamDefaultWriter<T>(dest);\n\n  source._disturbed = true;\n\n  let shuttingDown = false;\n\n  // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n  let currentWrite = promiseResolvedWith<void>(undefined);\n\n  return newPromise((resolve, reject) => {\n    let abortAlgorithm: () => void;\n    if (signal !== undefined) {\n      abortAlgorithm = () => {\n        const error = signal.reason !== undefined ? signal.reason : new DOMException('Aborted', 'AbortError');\n        const actions: Array<() => Promise<void>> = [];\n        if (!preventAbort) {\n          actions.push(() => {\n            if (dest._state === 'writable') {\n              return WritableStreamAbort(dest, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        if (!preventCancel) {\n          actions.push(() => {\n            if (source._state === 'readable') {\n              return ReadableStreamCancel(source, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n      };\n\n      if (signal.aborted) {\n        abortAlgorithm();\n        return;\n      }\n\n      signal.addEventListener('abort', abortAlgorithm);\n    }\n\n    // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n    function pipeLoop() {\n      return newPromise<void>((resolveLoop, rejectLoop) => {\n        function next(done: boolean) {\n          if (done) {\n            resolveLoop();\n          } else {\n            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n            PerformPromiseThen(pipeStep(), next, rejectLoop);\n          }\n        }\n\n        next(false);\n      });\n    }\n\n    function pipeStep(): Promise<boolean> {\n      if (shuttingDown) {\n        return promiseResolvedWith(true);\n      }\n\n      return PerformPromiseThen(writer._readyPromise, () => {\n        return newPromise<boolean>((resolveRead, rejectRead) => {\n          ReadableStreamDefaultReaderRead(\n            reader,\n            {\n              _chunkSteps: chunk => {\n                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                resolveRead(false);\n              },\n              _closeSteps: () => resolveRead(true),\n              _errorSteps: rejectRead\n            }\n          );\n        });\n      });\n    }\n\n    // Errors must be propagated forward\n    isOrBecomesErrored(source, reader._closedPromise, storedError => {\n      if (!preventAbort) {\n        shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n      return null;\n    });\n\n    // Errors must be propagated backward\n    isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n      return null;\n    });\n\n    // Closing must be propagated forward\n    isOrBecomesClosed(source, reader._closedPromise, () => {\n      if (!preventClose) {\n        shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n      } else {\n        shutdown();\n      }\n      return null;\n    });\n\n    // Closing must be propagated backward\n    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n      const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n\n    setPromiseIsHandledToTrue(pipeLoop());\n\n    function waitForWritesToFinish(): Promise<void> {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      const oldCurrentWrite = currentWrite;\n      return PerformPromiseThen(\n        currentWrite,\n        () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined\n      );\n    }\n\n    function isOrBecomesErrored(stream: ReadableStream | WritableStream,\n                                promise: Promise<void>,\n                                action: (reason: any) => null) {\n      if (stream._state === 'errored') {\n        action(stream._storedError);\n      } else {\n        uponRejection(promise, action);\n      }\n    }\n\n    function isOrBecomesClosed(stream: ReadableStream | WritableStream, promise: Promise<void>, action: () => null) {\n      if (stream._state === 'closed') {\n        action();\n      } else {\n        uponFulfillment(promise, action);\n      }\n    }\n\n    function shutdownWithAction(action: () => Promise<unknown>, originalIsError?: boolean, originalError?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), doTheRest);\n      } else {\n        doTheRest();\n      }\n\n      function doTheRest(): null {\n        uponPromise(\n          action(),\n          () => finalize(originalIsError, originalError),\n          newError => finalize(true, newError)\n        );\n        return null;\n      }\n    }\n\n    function shutdown(isError?: boolean, error?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n      } else {\n        finalize(isError, error);\n      }\n    }\n\n    function finalize(isError?: boolean, error?: any): null {\n      WritableStreamDefaultWriterRelease(writer);\n      ReadableStreamReaderGenericRelease(reader);\n\n      if (signal !== undefined) {\n        signal.removeEventListener('abort', abortAlgorithm);\n      }\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n\n      return null;\n    }\n  });\n}\n","import type { QueuingStrategySizeCallback } from '../queuing-strategy';\nimport assert from '../../stub/assert';\nimport { DequeueValue, EnqueueValueWithSize, type QueuePair, ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  type ReadRequest\n} from './default-reader';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsReadableStreamLocked, ReadableStream, ReadableStreamClose, ReadableStreamError } from '../readable-stream';\nimport type { ValidatedUnderlyingSource } from './underlying-source';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { CancelSteps, PullSteps, ReleaseSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableStreamDefaultController<R> {\n  /** @internal */\n  _controlledReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<R>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<R>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the controlled readable stream.\n   */\n  enqueue(chunk: R): void;\n  enqueue(chunk: R = undefined!): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<R>): void {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      readRequest._chunkSteps(chunk);\n    } else {\n      ReadableStreamAddReadRequest(stream, readRequest);\n      ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    }\n  }\n\n  /** @internal */\n  [ReleaseSteps](): void {\n    // Do nothing.\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(ReadableStreamDefaultController.prototype.close, 'close');\nsetFunctionName(ReadableStreamDefaultController.prototype.enqueue, 'enqueue');\nsetFunctionName(ReadableStreamDefaultController.prototype.error, 'error');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController<R = any>(x: any): x is ReadableStreamDefaultController<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultController;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller: ReadableStreamDefaultController<any>): void {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n\n      return null;\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n      return null;\n    }\n  );\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller: ReadableStreamDefaultController<any>): boolean {\n  const stream = controller._controlledReadableStream;\n\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller: ReadableStreamDefaultController<any>) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nexport function ReadableStreamDefaultControllerClose(controller: ReadableStreamDefaultController<any>) {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nexport function ReadableStreamDefaultControllerEnqueue<R>(\n  controller: ReadableStreamDefaultController<R>,\n  chunk: R\n): void {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableStreamDefaultControllerError(controller: ReadableStreamDefaultController<any>, e: any) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableStreamDefaultControllerGetDesiredSize(\n  controller: ReadableStreamDefaultController<any>\n): number | null {\n  const state = controller._controlledReadableStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nexport function ReadableStreamDefaultControllerHasBackpressure(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function ReadableStreamDefaultControllerCanCloseOrEnqueue(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  const state = controller._controlledReadableStream._state;\n\n  if (!controller._closeRequested && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function SetUpReadableStreamDefaultController<R>(stream: ReadableStream<R>,\n                                                        controller: ReadableStreamDefaultController<R>,\n                                                        startAlgorithm: () => void | PromiseLike<void>,\n                                                        pullAlgorithm: () => Promise<void>,\n                                                        cancelAlgorithm: (reason: any) => Promise<void>,\n                                                        highWaterMark: number,\n                                                        sizeAlgorithm: QueuingStrategySizeCallback<R>) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      return null;\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n      return null;\n    }\n  );\n}\n\nexport function SetUpReadableStreamDefaultControllerFromUnderlyingSource<R>(\n  stream: ReadableStream<R>,\n  underlyingSource: ValidatedUnderlyingSource<R>,\n  highWaterMark: number,\n  sizeAlgorithm: QueuingStrategySizeCallback<R>\n) {\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let pullAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingSource.start !== undefined) {\n    startAlgorithm = () => underlyingSource.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingSource.pull!(controller);\n  } else {\n    pullAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingSource.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n","import {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  type DefaultReadableStream,\n  IsReadableStream,\n  type ReadableByteStream,\n  ReadableStream,\n  ReadableStreamCancel,\n  type ReadableStreamReader\n} from '../readable-stream';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  type ReadRequest\n} from './default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderRead,\n  type ReadIntoRequest\n} from './byob-reader';\nimport assert from '../../stub/assert';\nimport { newPromise, promiseResolvedWith, queueMicrotask, uponRejection } from '../helpers/webidl';\nimport {\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError\n} from './default-controller';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamControllerClose,\n  ReadableByteStreamControllerEnqueue,\n  ReadableByteStreamControllerError,\n  ReadableByteStreamControllerGetBYOBRequest,\n  ReadableByteStreamControllerRespond,\n  ReadableByteStreamControllerRespondWithNewView\n} from './byte-stream-controller';\nimport { CreateArrayFromList } from '../abstract-ops/ecmascript';\nimport { CloneAsUint8Array } from '../abstract-ops/miscellaneous';\nimport type { NonShared } from '../helpers/array-buffer-view';\n\nexport function ReadableStreamTee<R>(stream: ReadableStream<R>,\n                                     cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n  if (IsReadableByteStreamController(stream._readableStreamController)) {\n    return ReadableByteStreamTee(stream as unknown as ReadableByteStream) as\n      unknown as [ReadableStream<R>, ReadableStream<R>];\n  }\n  return ReadableStreamDefaultTee(stream, cloneForBranch2);\n}\n\nexport function ReadableStreamDefaultTee<R>(\n  stream: ReadableStream<R>,\n  cloneForBranch2: boolean\n): [DefaultReadableStream<R>, DefaultReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n\n  let reading = false;\n  let readAgain = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: DefaultReadableStream<R>;\n  let branch2: DefaultReadableStream<R>;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<undefined>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm(): Promise<void> {\n    if (reading) {\n      readAgain = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgain = false;\n          const chunk1 = chunk;\n          const chunk2 = chunk;\n\n          // There is no way to access the cloning code right now in the reference implementation.\n          // If we add one then we'll need an implementation for serializable objects.\n          // if (!canceled2 && cloneForBranch2) {\n          //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n          // }\n\n          if (!canceled1) {\n            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n\n          reading = false;\n          if (readAgain) {\n            pullAlgorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {\n    // do nothing\n  }\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  uponRejection(reader._closedPromise, (r: any) => {\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    if (!canceled1 || !canceled2) {\n      resolveCancelPromise(undefined);\n    }\n    return null;\n  });\n\n  return [branch1, branch2];\n}\n\nexport function ReadableByteStreamTee(stream: ReadableByteStream): [ReadableByteStream, ReadableByteStream] {\n  assert(IsReadableStream(stream));\n  assert(IsReadableByteStreamController(stream._readableStreamController));\n\n  let reader: ReadableStreamReader<NonShared<Uint8Array>> = AcquireReadableStreamDefaultReader(stream);\n  let reading = false;\n  let readAgainForBranch1 = false;\n  let readAgainForBranch2 = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: ReadableByteStream;\n  let branch2: ReadableByteStream;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<void>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function forwardReaderError(thisReader: ReadableStreamReader<NonShared<Uint8Array>>) {\n    uponRejection(thisReader._closedPromise, r => {\n      if (thisReader !== reader) {\n        return null;\n      }\n      ReadableByteStreamControllerError(branch1._readableStreamController, r);\n      ReadableByteStreamControllerError(branch2._readableStreamController, r);\n      if (!canceled1 || !canceled2) {\n        resolveCancelPromise(undefined);\n      }\n      return null;\n    });\n  }\n\n  function pullWithDefaultReader() {\n    if (IsReadableStreamBYOBReader(reader)) {\n      assert(reader._readIntoRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamDefaultReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const readRequest: ReadRequest<NonShared<Uint8Array>> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const chunk1 = chunk;\n          let chunk2 = chunk;\n          if (!canceled1 && !canceled2) {\n            try {\n              chunk2 = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n          }\n\n          if (!canceled1) {\n            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableByteStreamControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableByteStreamControllerClose(branch2._readableStreamController);\n        }\n        if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n        }\n        if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n        }\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n  }\n\n  function pullWithBYOBReader(view: NonShared<ArrayBufferView>, forBranch2: boolean) {\n    if (IsReadableStreamDefaultReader<NonShared<Uint8Array>>(reader)) {\n      assert(reader._readRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamBYOBReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const byobBranch = forBranch2 ? branch2 : branch1;\n    const otherBranch = forBranch2 ? branch1 : branch2;\n\n    const readIntoRequest: ReadIntoRequest<NonShared<ArrayBufferView>> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n          if (!otherCanceled) {\n            let clonedChunk;\n            try {\n              clonedChunk = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n            if (!byobCanceled) {\n              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n            }\n            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n          } else if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: chunk => {\n        reading = false;\n\n        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n        if (!byobCanceled) {\n          ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n        }\n        if (!otherCanceled) {\n          ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n        }\n\n        if (chunk !== undefined) {\n          assert(chunk.byteLength === 0);\n\n          if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n          if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n          }\n        }\n\n        if (!byobCanceled || !otherCanceled) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n  }\n\n  function pull1Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch1 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, false);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function pull2Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch2 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, true);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm(): void {\n    return;\n  }\n\n  branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n  branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n\n  forwardReaderError(reader);\n\n  return [branch1, branch2];\n}\n","import { typeIsObject } from '../helpers/miscellaneous';\nimport type { ReadableStreamDefaultReadResult } from './default-reader';\n\n/**\n * A common interface for a `ReadadableStream` implementation.\n *\n * @public\n */\nexport interface ReadableStreamLike<R = any> {\n  readonly locked: boolean;\n\n  getReader(): ReadableStreamDefaultReaderLike<R>;\n}\n\n/**\n * A common interface for a `ReadableStreamDefaultReader` implementation.\n *\n * @public\n */\nexport interface ReadableStreamDefaultReaderLike<R = any> {\n  readonly closed: Promise<undefined>;\n\n  cancel(reason?: any): Promise<void>;\n\n  read(): Promise<ReadableStreamDefaultReadResult<R>>;\n\n  releaseLock(): void;\n}\n\nexport function isReadableStreamLike<R>(stream: unknown): stream is ReadableStreamLike<R> {\n  return typeIsObject(stream) && typeof (stream as ReadableStreamLike<R>).getReader !== 'undefined';\n}\n","import { CreateReadableStream, type DefaultReadableStream } from '../readable-stream';\nimport {\n  isReadableStreamLike,\n  type ReadableStreamDefaultReaderLike,\n  type ReadableStreamLike\n} from './readable-stream-like';\nimport { ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue } from './default-controller';\nimport { GetIterator, GetMethod, IteratorComplete, IteratorNext, IteratorValue } from '../abstract-ops/ecmascript';\nimport { promiseRejectedWith, promiseResolvedWith, reflectCall, transformPromiseWith } from '../helpers/webidl';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { noop } from '../../utils';\n\nexport function ReadableStreamFrom<R>(\n  source: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>\n): DefaultReadableStream<R> {\n  if (isReadableStreamLike(source)) {\n    return ReadableStreamFromDefaultReader(source.getReader());\n  }\n  return ReadableStreamFromIterable(source);\n}\n\nexport function ReadableStreamFromIterable<R>(asyncIterable: Iterable<R> | AsyncIterable<R>): DefaultReadableStream<R> {\n  let stream: DefaultReadableStream<R>;\n  const iteratorRecord = GetIterator(asyncIterable, 'async');\n\n  const startAlgorithm = noop;\n\n  function pullAlgorithm(): Promise<void> {\n    let nextResult;\n    try {\n      nextResult = IteratorNext(iteratorRecord);\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const nextPromise = promiseResolvedWith(nextResult);\n    return transformPromiseWith(nextPromise, iterResult => {\n      if (!typeIsObject(iterResult)) {\n        throw new TypeError('The promise returned by the iterator.next() method must fulfill with an object');\n      }\n      const done = IteratorComplete(iterResult);\n      if (done) {\n        ReadableStreamDefaultControllerClose(stream._readableStreamController);\n      } else {\n        const value = IteratorValue(iterResult);\n        ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n      }\n    });\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    const iterator = iteratorRecord.iterator;\n    let returnMethod: (typeof iterator)['return'] | undefined;\n    try {\n      returnMethod = GetMethod(iterator, 'return');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    if (returnMethod === undefined) {\n      return promiseResolvedWith(undefined);\n    }\n    let returnResult: IteratorResult<R> | Promise<IteratorResult<R>>;\n    try {\n      returnResult = reflectCall(returnMethod, iterator, [reason]);\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const returnPromise = promiseResolvedWith(returnResult);\n    return transformPromiseWith(returnPromise, iterResult => {\n      if (!typeIsObject(iterResult)) {\n        throw new TypeError('The promise returned by the iterator.return() method must fulfill with an object');\n      }\n      return undefined;\n    });\n  }\n\n  stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n  return stream;\n}\n\nexport function ReadableStreamFromDefaultReader<R>(\n  reader: ReadableStreamDefaultReaderLike<R>\n): DefaultReadableStream<R> {\n  let stream: DefaultReadableStream<R>;\n\n  const startAlgorithm = noop;\n\n  function pullAlgorithm(): Promise<void> {\n    let readPromise;\n    try {\n      readPromise = reader.read();\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    return transformPromiseWith(readPromise, readResult => {\n      if (!typeIsObject(readResult)) {\n        throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n      }\n      if (readResult.done) {\n        ReadableStreamDefaultControllerClose(stream._readableStreamController);\n      } else {\n        const value = readResult.value;\n        ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n      }\n    });\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    try {\n      return promiseResolvedWith(reader.cancel(reason));\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n  }\n\n  stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n  return stream;\n}\n","import { assertDictionary, assertFunction, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport type {\n  ReadableStreamController,\n  UnderlyingByteSource,\n  UnderlyingDefaultOrByteSource,\n  UnderlyingDefaultOrByteSourcePullCallback,\n  UnderlyingDefaultOrByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  ValidatedUnderlyingDefaultOrByteSource\n} from '../readable-stream/underlying-source';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\n\nexport function convertUnderlyingDefaultOrByteSource<R>(\n  source: UnderlyingSource<R> | UnderlyingByteSource | null,\n  context: string\n): ValidatedUnderlyingDefaultOrByteSource<R> {\n  assertDictionary(source, context);\n  const original = source as (UnderlyingDefaultOrByteSource<R> | null);\n  const autoAllocateChunkSize = original?.autoAllocateChunkSize;\n  const cancel = original?.cancel;\n  const pull = original?.pull;\n  const start = original?.start;\n  const type = original?.type;\n  return {\n    autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n      undefined :\n      convertUnsignedLongLongWithEnforceRange(\n        autoAllocateChunkSize,\n        `${context} has member 'autoAllocateChunkSize' that`\n      ),\n    cancel: cancel === undefined ?\n      undefined :\n      convertUnderlyingSourceCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    pull: pull === undefined ?\n      undefined :\n      convertUnderlyingSourcePullCallback(pull, original!, `${context} has member 'pull' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSourceStartCallback(start, original!, `${context} has member 'start' that`),\n    type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n  };\n}\n\nfunction convertUnderlyingSourceCancelCallback(\n  fn: UnderlyingSourceCancelCallback,\n  original: UnderlyingDefaultOrByteSource,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSourcePullCallback<R>(\n  fn: UnderlyingDefaultOrByteSourcePullCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): (controller: ReadableStreamController<R>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSourceStartCallback<R>(\n  fn: UnderlyingDefaultOrByteSourceStartCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): UnderlyingDefaultOrByteSourceStartCallback<R> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertReadableStreamType(type: string, context: string): 'bytes' {\n  type = `${type}`;\n  if (type !== 'bytes') {\n    throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n  }\n  return type;\n}\n","import { assertDictionary } from './basic';\nimport type {\n  ReadableStreamIteratorOptions,\n  ValidatedReadableStreamIteratorOptions\n} from '../readable-stream/iterator-options';\n\nexport function convertIteratorOptions(options: ReadableStreamIteratorOptions | null | undefined,\n                                       context: string): ValidatedReadableStreamIteratorOptions {\n  assertDictionary(options, context);\n  const preventCancel = options?.preventCancel;\n  return { preventCancel: Boolean(preventCancel) };\n}\n","import { assertDictionary } from './basic';\nimport type { StreamPipeOptions, ValidatedStreamPipeOptions } from '../readable-stream/pipe-options';\nimport { type AbortSignal, isAbortSignal } from '../abort-signal';\n\nexport function convertPipeOptions(options: StreamPipeOptions | null | undefined,\n                                   context: string): ValidatedStreamPipeOptions {\n  assertDictionary(options, context);\n  const preventAbort = options?.preventAbort;\n  const preventCancel = options?.preventCancel;\n  const preventClose = options?.preventClose;\n  const signal = options?.signal;\n  if (signal !== undefined) {\n    assertAbortSignal(signal, `${context} has member 'signal' that`);\n  }\n  return {\n    preventAbort: Boolean(preventAbort),\n    preventCancel: Boolean(preventCancel),\n    preventClose: Boolean(preventClose),\n    signal\n  };\n}\n\nfunction assertAbortSignal(signal: unknown, context: string): asserts signal is AbortSignal {\n  if (!isAbortSignal(signal)) {\n    throw new TypeError(`${context} is not an AbortSignal.`);\n  }\n}\n","import { assertDictionary, assertRequiredField } from './basic';\nimport { ReadableStream } from '../readable-stream';\nimport { WritableStream } from '../writable-stream';\nimport { assertReadableStream } from './readable-stream';\nimport { assertWritableStream } from './writable-stream';\n\nexport function convertReadableWritablePair<RS extends ReadableStream, WS extends WritableStream>(\n  pair: { readable: RS; writable: WS } | null | undefined,\n  context: string\n): { readable: RS; writable: WS } {\n  assertDictionary(pair, context);\n\n  const readable = pair?.readable;\n  assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n  assertReadableStream(readable, `${context} has member 'readable' that`);\n\n  const writable = pair?.writable;\n  assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n  assertWritableStream(writable, `${context} has member 'writable' that`);\n\n  return { readable, writable };\n}\n","import assert from '../stub/assert';\nimport {\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith\n} from './helpers/webidl';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { AcquireReadableStreamAsyncIterator, type ReadableStreamAsyncIterator } from './readable-stream/async-iterator';\nimport { defaultReaderClosedPromiseReject, defaultReaderClosedPromiseResolve } from './readable-stream/generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderErrorReadRequests,\n  type ReadableStreamDefaultReadResult\n} from './readable-stream/default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderErrorReadIntoRequests,\n  type ReadableStreamBYOBReadResult\n} from './readable-stream/byob-reader';\nimport { ReadableStreamPipeTo } from './readable-stream/pipe';\nimport { ReadableStreamTee } from './readable-stream/tee';\nimport { ReadableStreamFrom } from './readable-stream/from';\nimport { IsWritableStream, IsWritableStreamLocked, WritableStream } from './writable-stream';\nimport { SimpleQueue } from './simple-queue';\nimport {\n  ReadableByteStreamController,\n  ReadableStreamBYOBRequest,\n  SetUpReadableByteStreamController,\n  SetUpReadableByteStreamControllerFromUnderlyingSource\n} from './readable-stream/byte-stream-controller';\nimport {\n  ReadableStreamDefaultController,\n  SetUpReadableStreamDefaultController,\n  SetUpReadableStreamDefaultControllerFromUnderlyingSource\n} from './readable-stream/default-controller';\nimport type {\n  UnderlyingByteSource,\n  UnderlyingByteSourcePullCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceStartCallback\n} from './readable-stream/underlying-source';\nimport { noop } from '../utils';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { CreateArrayFromList, SymbolAsyncIterator } from './abstract-ops/ecmascript';\nimport { CancelSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertUnderlyingDefaultOrByteSource } from './validators/underlying-source';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ReadableStreamGetReaderOptions\n} from './readable-stream/reader-options';\nimport { convertReaderOptions } from './validators/reader-options';\nimport type { StreamPipeOptions, ValidatedStreamPipeOptions } from './readable-stream/pipe-options';\nimport type { ReadableStreamIteratorOptions } from './readable-stream/iterator-options';\nimport { convertIteratorOptions } from './validators/iterator-options';\nimport { convertPipeOptions } from './validators/pipe-options';\nimport type { ReadableWritablePair } from './readable-stream/readable-writable-pair';\nimport { convertReadableWritablePair } from './validators/readable-writable-pair';\nimport type { ReadableStreamDefaultReaderLike, ReadableStreamLike } from './readable-stream/readable-stream-like';\nimport type { NonShared } from './helpers/array-buffer-view';\n\nexport type DefaultReadableStream<R = any> = ReadableStream<R> & {\n  _readableStreamController: ReadableStreamDefaultController<R>\n};\n\nexport type ReadableByteStream = ReadableStream<NonShared<Uint8Array>> & {\n  _readableStreamController: ReadableByteStreamController\n};\n\ntype ReadableStreamState = 'readable' | 'closed' | 'errored';\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nexport class ReadableStream<R = any> implements AsyncIterable<R> {\n  /** @internal */\n  _state!: ReadableStreamState;\n  /** @internal */\n  _reader: ReadableStreamReader<R> | undefined;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _disturbed!: boolean;\n  /** @internal */\n  _readableStreamController!: ReadableStreamDefaultController<R> | ReadableByteStreamController;\n\n  constructor(underlyingSource: UnderlyingByteSource, strategy?: { highWaterMark?: number; size?: undefined });\n  constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);\n  constructor(rawUnderlyingSource: UnderlyingSource<R> | UnderlyingByteSource | null | undefined = {},\n              rawStrategy: QueuingStrategy<R> | null | undefined = {}) {\n    if (rawUnderlyingSource === undefined) {\n      rawUnderlyingSource = null;\n    } else {\n      assertObject(rawUnderlyingSource, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n\n    InitializeReadableStream(this);\n\n    if (underlyingSource.type === 'bytes') {\n      if (strategy.size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n      const highWaterMark = ExtractHighWaterMark(strategy, 0);\n      SetUpReadableByteStreamControllerFromUnderlyingSource(\n        this as unknown as ReadableByteStream,\n        underlyingSource,\n        highWaterMark\n      );\n    } else {\n      assert(underlyingSource.type === undefined);\n      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n      const highWaterMark = ExtractHighWaterMark(strategy, 1);\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(\n        this,\n        underlyingSource,\n        highWaterMark,\n        sizeAlgorithm\n      );\n    }\n  }\n\n  /**\n   * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n   */\n  get locked(): boolean {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  /**\n   * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n   *\n   * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n   * method, which might or might not use it.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  /**\n   * Creates a {@link ReadableStreamBYOBReader} and locks the stream to the new reader.\n   *\n   * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams,\n   * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   * control over allocation.\n   */\n  getReader({ mode }: { mode: 'byob' }): ReadableStreamBYOBReader;\n  /**\n   * Creates a {@link ReadableStreamDefaultReader} and locks the stream to the new reader.\n   * While the stream is locked, no other reader can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to consume a stream\n   * in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours\n   * or cancel the stream, which would interfere with your abstraction.\n   */\n  getReader(): ReadableStreamDefaultReader<R>;\n  getReader(\n    rawOptions: ReadableStreamGetReaderOptions | null | undefined = undefined\n  ): ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    const options = convertReaderOptions(rawOptions, 'First parameter');\n\n    if (options.mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    assert(options.mode === 'byob');\n    return AcquireReadableStreamBYOBReader(this as unknown as ReadableByteStream);\n  }\n\n  /**\n   * Provides a convenient, chainable way of piping this readable stream through a transform stream\n   * (or any other `{ writable, readable }` pair). It simply {@link ReadableStream.pipeTo | pipes} the stream\n   * into the writable side of the supplied pair, and returns the readable side for further use.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeThrough<RS extends ReadableStream>(\n    transform: { readable: RS; writable: WritableStream<R> },\n    options?: StreamPipeOptions\n  ): RS;\n  pipeThrough<RS extends ReadableStream>(\n    rawTransform: { readable: RS; writable: WritableStream<R> } | null | undefined,\n    rawOptions: StreamPipeOptions | null | undefined = {}\n  ): RS {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('pipeThrough');\n    }\n    assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n\n    const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n    const options = convertPipeOptions(rawOptions, 'Second parameter');\n\n    if (IsReadableStreamLocked(this)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n    }\n    if (IsWritableStreamLocked(transform.writable)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n    }\n\n    const promise = ReadableStreamPipeTo(\n      this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n\n    setPromiseIsHandledToTrue(promise);\n\n    return transform.readable;\n  }\n\n  /**\n   * Pipes this readable stream to a given writable stream. The way in which the piping process behaves under\n   * various error conditions can be customized with a number of passed options. It returns a promise that fulfills\n   * when the piping process completes successfully, or rejects if any errors were encountered.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;\n  pipeTo(destination: WritableStream<R> | null | undefined,\n         rawOptions: StreamPipeOptions | null | undefined = {}): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('pipeTo'));\n    }\n\n    if (destination === undefined) {\n      return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n    }\n    if (!IsWritableStream(destination)) {\n      return promiseRejectedWith(\n        new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`)\n      );\n    }\n\n    let options: ValidatedStreamPipeOptions;\n    try {\n      options = convertPipeOptions(rawOptions, 'Second parameter');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream')\n      );\n    }\n    if (IsWritableStreamLocked(destination)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream')\n      );\n    }\n\n    return ReadableStreamPipeTo<R>(\n      this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n  }\n\n  /**\n   * Tees this readable stream, returning a two-element array containing the two resulting branches as\n   * new {@link ReadableStream} instances.\n   *\n   * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n   * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n   * propagated to the stream's underlying source.\n   *\n   * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n   * this could allow interference between the two branches.\n   */\n  tee(): [ReadableStream<R>, ReadableStream<R>] {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return CreateArrayFromList(branches);\n  }\n\n  /**\n   * Asynchronously iterates over the chunks in the stream's internal queue.\n   *\n   * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n   * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n   * is called, e.g. by breaking out of the loop.\n   *\n   * By default, calling the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method will also\n   * cancel the stream. To prevent this, use the stream's {@link ReadableStream.values | values()} method, passing\n   * `true` for the `preventCancel` option.\n   */\n  values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n  values(rawOptions: ReadableStreamIteratorOptions | null | undefined = undefined): ReadableStreamAsyncIterator<R> {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('values');\n    }\n\n    const options = convertIteratorOptions(rawOptions, 'First parameter');\n    return AcquireReadableStreamAsyncIterator<R>(this, options.preventCancel);\n  }\n\n  /**\n   * {@inheritDoc ReadableStream.values}\n   */\n  [Symbol.asyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n\n  [SymbolAsyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R> {\n    // Stub implementation, overridden below\n    return this.values(options);\n  }\n\n  /**\n   * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n   *\n   * This can be used to adapt various kinds of objects into a readable stream,\n   * such as an array, an async generator, or a Node.js readable stream.\n   */\n  static from<R>(asyncIterable: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>): ReadableStream<R> {\n    return ReadableStreamFrom(asyncIterable);\n  }\n}\n\nObject.defineProperties(ReadableStream, {\n  from: { enumerable: true }\n});\nObject.defineProperties(ReadableStream.prototype, {\n  cancel: { enumerable: true },\n  getReader: { enumerable: true },\n  pipeThrough: { enumerable: true },\n  pipeTo: { enumerable: true },\n  tee: { enumerable: true },\n  values: { enumerable: true },\n  locked: { enumerable: true }\n});\nsetFunctionName(ReadableStream.from, 'from');\nsetFunctionName(ReadableStream.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStream.prototype.getReader, 'getReader');\nsetFunctionName(ReadableStream.prototype.pipeThrough, 'pipeThrough');\nsetFunctionName(ReadableStream.prototype.pipeTo, 'pipeTo');\nsetFunctionName(ReadableStream.prototype.tee, 'tee');\nsetFunctionName(ReadableStream.prototype.values, 'values');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {\n    value: 'ReadableStream',\n    configurable: true\n  });\n}\nObject.defineProperty(ReadableStream.prototype, SymbolAsyncIterator, {\n  value: ReadableStream.prototype.values,\n  writable: true,\n  configurable: true\n});\n\nexport type {\n  ReadableStreamAsyncIterator,\n  ReadableStreamDefaultReadResult,\n  ReadableStreamBYOBReadResult,\n  ReadableStreamBYOBReaderReadOptions,\n  UnderlyingByteSource,\n  UnderlyingSource,\n  UnderlyingSourceStartCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceCancelCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingByteSourcePullCallback,\n  StreamPipeOptions,\n  ReadableWritablePair,\n  ReadableStreamIteratorOptions,\n  ReadableStreamLike,\n  ReadableStreamDefaultReaderLike\n};\n\n// Abstract operations for the ReadableStream.\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableStream<R>(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>,\n  highWaterMark = 1,\n  sizeAlgorithm: QueuingStrategySizeCallback<R> = () => 1\n): DefaultReadableStream<R> {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: DefaultReadableStream<R> = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableByteStream(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>\n): ReadableByteStream {\n  const stream: ReadableByteStream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream: ReadableStream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nexport function IsReadableStream(x: unknown): x is ReadableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStream;\n}\n\nexport function IsReadableStreamDisturbed(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  return stream._disturbed;\n}\n\nexport function IsReadableStreamLocked(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamCancel<R>(stream: ReadableStream<R>, reason: any): Promise<undefined> {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const reader = stream._reader;\n  if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n    const readIntoRequests = reader._readIntoRequests;\n    reader._readIntoRequests = new SimpleQueue();\n    readIntoRequests.forEach(readIntoRequest => {\n      readIntoRequest._closeSteps(undefined);\n    });\n  }\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return transformPromiseWith(sourceCancelPromise, noop);\n}\n\nexport function ReadableStreamClose<R>(stream: ReadableStream<R>): void {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    const readRequests = reader._readRequests;\n    reader._readRequests = new SimpleQueue();\n    readRequests.forEach(readRequest => {\n      readRequest._closeSteps();\n    });\n  }\n}\n\nexport function ReadableStreamError<R>(stream: ReadableStream<R>, e: any): void {\n  assert(IsReadableStream(stream));\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n    ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n  }\n}\n\n// Readers\n\nexport type ReadableStreamReader<R> = ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader;\n\nexport {\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader\n};\n\n// Controllers\n\nexport {\n  ReadableStreamDefaultController,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController\n};\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n","import type { QueuingStrategyInit } from '../queuing-strategy';\nimport { assertDictionary, assertRequiredField, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategyInit(init: QueuingStrategyInit | null | undefined,\n                                           context: string): QueuingStrategyInit {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n  return {\n    highWaterMark: convertUnrestrictedDouble(highWaterMark)\n  };\n}\n","import type { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst byteLengthSizeFunction = (chunk: ArrayBufferView): number => {\n  return chunk.byteLength;\n};\nsetFunctionName(byteLengthSizeFunction, 'size');\n\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nexport default class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {\n  /** @internal */\n  readonly _byteLengthQueuingStrategyHighWaterMark: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('highWaterMark');\n    }\n    return this._byteLengthQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by returning the value of its `byteLength` property.\n   */\n  get size(): (chunk: ArrayBufferView) => number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('size');\n    }\n    return byteLengthSizeFunction;\n  }\n}\n\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'ByteLengthQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the ByteLengthQueuingStrategy.\n\nfunction byteLengthBrandCheckException(name: string): TypeError {\n  return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\n\nexport function IsByteLengthQueuingStrategy(x: any): x is ByteLengthQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof ByteLengthQueuingStrategy;\n}\n","import type { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst countSizeFunction = (): 1 => {\n  return 1;\n};\nsetFunctionName(countSizeFunction, 'size');\n\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nexport default class CountQueuingStrategy implements QueuingStrategy<any> {\n  /** @internal */\n  readonly _countQueuingStrategyHighWaterMark!: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('highWaterMark');\n    }\n    return this._countQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by always returning 1.\n   * This ensures that the total queue size is a count of the number of chunks in the queue.\n   */\n  get size(): (chunk: any) => 1 {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('size');\n    }\n    return countSizeFunction;\n  }\n}\n\nObject.defineProperties(CountQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'CountQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the CountQueuingStrategy.\n\nfunction countBrandCheckException(name: string): TypeError {\n  return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\n\nexport function IsCountQueuingStrategy(x: any): x is CountQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof CountQueuingStrategy;\n}\n","import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from '../transform-stream/transformer';\nimport { TransformStreamDefaultController } from '../transform-stream';\n\nexport function convertTransformer<I, O>(original: Transformer<I, O> | null,\n                                         context: string): ValidatedTransformer<I, O> {\n  assertDictionary(original, context);\n  const cancel = original?.cancel;\n  const flush = original?.flush;\n  const readableType = original?.readableType;\n  const start = original?.start;\n  const transform = original?.transform;\n  const writableType = original?.writableType;\n  return {\n    cancel: cancel === undefined ?\n      undefined :\n      convertTransformerCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    flush: flush === undefined ?\n      undefined :\n      convertTransformerFlushCallback(flush, original!, `${context} has member 'flush' that`),\n    readableType,\n    start: start === undefined ?\n      undefined :\n      convertTransformerStartCallback(start, original!, `${context} has member 'start' that`),\n    transform: transform === undefined ?\n      undefined :\n      convertTransformerTransformCallback(transform, original!, `${context} has member 'transform' that`),\n    writableType\n  };\n}\n\nfunction convertTransformerFlushCallback<I, O>(\n  fn: TransformerFlushCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): (controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertTransformerStartCallback<I, O>(\n  fn: TransformerStartCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): TransformerStartCallback<O> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertTransformerTransformCallback<I, O>(\n  fn: TransformerTransformCallback<I, O>,\n  original: Transformer<I, O>,\n  context: string\n): (chunk: I, controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: I, controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [chunk, controller]);\n}\n\nfunction convertTransformerCancelCallback<I, O>(\n  fn: TransformerCancelCallback,\n  original: Transformer<I, O>,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n","import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith,\n  uponPromise\n} from './helpers/webidl';\nimport { CreateReadableStream, type DefaultReadableStream, ReadableStream } from './readable-stream';\nimport {\n  ReadableStreamDefaultControllerCanCloseOrEnqueue,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure\n} from './readable-stream/default-controller';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { CreateWritableStream, WritableStream, WritableStreamDefaultControllerErrorIfNeeded } from './writable-stream';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from './transform-stream/transformer';\nimport { convertTransformer } from './validators/transformer';\n\n// Class TransformStream\n\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nexport class TransformStream<I = any, O = any> {\n  /** @internal */\n  _writable!: WritableStream<I>;\n  /** @internal */\n  _readable!: DefaultReadableStream<O>;\n  /** @internal */\n  _backpressure!: boolean;\n  /** @internal */\n  _backpressureChangePromise!: Promise<void>;\n  /** @internal */\n  _backpressureChangePromise_resolve!: () => void;\n  /** @internal */\n  _transformStreamController!: TransformStreamDefaultController<O>;\n\n  constructor(\n    transformer?: Transformer<I, O>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<O>\n  );\n  constructor(rawTransformer: Transformer<I, O> | null | undefined = {},\n              rawWritableStrategy: QueuingStrategy<I> | null | undefined = {},\n              rawReadableStrategy: QueuingStrategy<O> | null | undefined = {}) {\n    if (rawTransformer === undefined) {\n      rawTransformer = null;\n    }\n\n    const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n    const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n\n    const transformer = convertTransformer(rawTransformer, 'First parameter');\n    if (transformer.readableType !== undefined) {\n      throw new RangeError('Invalid readableType specified');\n    }\n    if (transformer.writableType !== undefined) {\n      throw new RangeError('Invalid writableType specified');\n    }\n\n    const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n    const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n    const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n    const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n\n    let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n    const startPromise = newPromise<void>(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(\n      this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm\n    );\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    if (transformer.start !== undefined) {\n      startPromise_resolve(transformer.start(this._transformStreamController));\n    } else {\n      startPromise_resolve(undefined);\n    }\n  }\n\n  /**\n   * The readable side of the transform stream.\n   */\n  get readable(): ReadableStream<O> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  /**\n   * The writable side of the transform stream.\n   */\n  get writable(): WritableStream<I> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\nObject.defineProperties(TransformStream.prototype, {\n  readable: { enumerable: true },\n  writable: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {\n    value: 'TransformStream',\n    configurable: true\n  });\n}\n\nexport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerStartCallback,\n  TransformerFlushCallback,\n  TransformerTransformCallback\n};\n\n// Transform Stream Abstract Operations\n\nexport function CreateTransformStream<I, O>(startAlgorithm: () => void | PromiseLike<void>,\n                                            transformAlgorithm: (chunk: I) => Promise<void>,\n                                            flushAlgorithm: () => Promise<void>,\n                                            cancelAlgorithm: (reason: any) => Promise<void>,\n                                            writableHighWaterMark = 1,\n                                            writableSizeAlgorithm: QueuingStrategySizeCallback<I> = () => 1,\n                                            readableHighWaterMark = 0,\n                                            readableSizeAlgorithm: QueuingStrategySizeCallback<O> = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream: TransformStream<I, O> = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n  const startPromise = newPromise<void>(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream<I, O>(stream: TransformStream<I, O>,\n                                         startPromise: Promise<void>,\n                                         writableHighWaterMark: number,\n                                         writableSizeAlgorithm: QueuingStrategySizeCallback<I>,\n                                         readableHighWaterMark: number,\n                                         readableSizeAlgorithm: QueuingStrategySizeCallback<O>) {\n  function startAlgorithm(): Promise<void> {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk: I): Promise<void> {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined!;\n  stream._backpressureChangePromise = undefined!;\n  stream._backpressureChangePromise_resolve = undefined!;\n  TransformStreamSetBackpressure(stream, true);\n\n  stream._transformStreamController = undefined!;\n}\n\nfunction IsTransformStream(x: unknown): x is TransformStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return x instanceof TransformStream;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream: TransformStream, e: any) {\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream: TransformStream, e: any) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  TransformStreamUnblockWrite(stream);\n}\n\nfunction TransformStreamUnblockWrite(stream: TransformStream) {\n  if (stream._backpressure) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream: TransformStream, backpressure: boolean) {\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = newPromise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nexport class TransformStreamDefaultController<O> {\n  /** @internal */\n  _controlledTransformStream: TransformStream<any, O>;\n  /** @internal */\n  _finishPromise: Promise<undefined> | undefined;\n  /** @internal */\n  _finishPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _finishPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _transformAlgorithm: (chunk: any) => Promise<void>;\n  /** @internal */\n  _flushAlgorithm: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.\n   */\n  get desiredSize(): number | null {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the readable side of the controlled transform stream.\n   */\n  enqueue(chunk: O): void;\n  enqueue(chunk: O = undefined!): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors both the readable side and the writable side of the controlled transform stream, making all future\n   * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n   */\n  error(reason: any = undefined): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  /**\n   * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n   * transformer only needs to consume a portion of the chunks written to the writable side.\n   */\n  terminate(): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  terminate: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(TransformStreamDefaultController.prototype.enqueue, 'enqueue');\nsetFunctionName(TransformStreamDefaultController.prototype.error, 'error');\nsetFunctionName(TransformStreamDefaultController.prototype.terminate, 'terminate');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'TransformStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController<O = any>(x: any): x is TransformStreamDefaultController<O> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return x instanceof TransformStreamDefaultController;\n}\n\nfunction SetUpTransformStreamDefaultController<I, O>(stream: TransformStream<I, O>,\n                                                     controller: TransformStreamDefaultController<O>,\n                                                     transformAlgorithm: (chunk: I) => Promise<void>,\n                                                     flushAlgorithm: () => Promise<void>,\n                                                     cancelAlgorithm: (reason: any) => Promise<void>) {\n  assert(IsTransformStream(stream));\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._finishPromise = undefined;\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer<I, O>(stream: TransformStream<I, O>,\n                                                                    transformer: ValidatedTransformer<I, O>) {\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm: (chunk: I) => Promise<void>;\n  let flushAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (transformer.transform !== undefined) {\n    transformAlgorithm = chunk => transformer.transform!(chunk, controller);\n  } else {\n    transformAlgorithm = chunk => {\n      try {\n        TransformStreamDefaultControllerEnqueue(controller, chunk as unknown as O);\n        return promiseResolvedWith(undefined);\n      } catch (transformResultE) {\n        return promiseRejectedWith(transformResultE);\n      }\n    };\n  }\n\n  if (transformer.flush !== undefined) {\n    flushAlgorithm = () => transformer.flush!(controller);\n  } else {\n    flushAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  if (transformer.cancel !== undefined) {\n    cancelAlgorithm = reason => transformer.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller: TransformStreamDefaultController<any>) {\n  controller._transformAlgorithm = undefined!;\n  controller._flushAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\nfunction TransformStreamDefaultControllerEnqueue<O>(controller: TransformStreamDefaultController<O>, chunk: O) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller: TransformStreamDefaultController<any>, e: any) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform<I, O>(controller: TransformStreamDefaultController<O>,\n                                                                chunk: I) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromiseWith(transformPromise, undefined, r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate<O>(controller: TransformStreamDefaultController<O>) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  ReadableStreamDefaultControllerClose(readableController);\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm<I, O>(stream: TransformStream<I, O>, chunk: I): Promise<void> {\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return transformPromiseWith(backpressureChangePromise, () => {\n      const writable = stream._writable;\n      const state = writable._state;\n      if (state === 'erroring') {\n        throw writable._storedError;\n      }\n      assert(state === 'writable');\n      return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n    });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm<I, O>(stream: TransformStream<I, O>, reason: any): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,\n  // we don't run the _cancelAlgorithm again.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const cancelPromise = controller._cancelAlgorithm(reason);\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(cancelPromise, () => {\n    if (readable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, readable._storedError);\n    } else {\n      ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm<I, O>(stream: TransformStream<I, O>): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,\n  // we don't also run the _cancelAlgorithm.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(flushPromise, () => {\n    if (readable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, readable._storedError);\n    } else {\n      ReadableStreamDefaultControllerClose(readable._readableStreamController);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream: TransformStream): Promise<void> {\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nfunction TransformStreamDefaultSourceCancelAlgorithm<I, O>(stream: TransformStream<I, O>, reason: any): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._writable cannot change after construction, so caching it across a call to user code is safe.\n  const writable = stream._writable;\n\n  // Assign the _finishPromise now so that if _flushAlgorithm calls writable.abort() or\n  // writable.cancel() internally, we don't run the _cancelAlgorithm again, or also run the\n  // _flushAlgorithm.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const cancelPromise = controller._cancelAlgorithm(reason);\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(cancelPromise, () => {\n    if (writable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, writable._storedError);\n    } else {\n      WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);\n      TransformStreamUnblockWrite(stream);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);\n    TransformStreamUnblockWrite(stream);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\nexport function defaultControllerFinishPromiseResolve(controller: TransformStreamDefaultController<any>) {\n  if (controller._finishPromise_resolve === undefined) {\n    return;\n  }\n\n  controller._finishPromise_resolve();\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\nexport function defaultControllerFinishPromiseReject(controller: TransformStreamDefaultController<any>, reason: any) {\n  if (controller._finishPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(controller._finishPromise!);\n  controller._finishPromise_reject(reason);\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n","/* c8 ignore start */\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\nif (!globalThis.ReadableStream) {\n  // `node:stream/web` got introduced in v16.5.0 as experimental\n  // and it's preferred over the polyfilled version. So we also\n  // suppress the warning that gets emitted by NodeJS for using it.\n  try {\n    const process = require('node:process')\n    const { emitWarning } = process\n    try {\n      process.emitWarning = () => {}\n      Object.assign(globalThis, require('node:stream/web'))\n      process.emitWarning = emitWarning\n    } catch (error) {\n      process.emitWarning = emitWarning\n      throw error\n    }\n  } catch (error) {\n    // fallback to polyfill implementation\n    Object.assign(globalThis, require('web-streams-polyfill/dist/ponyfill.es2018.js'))\n  }\n}\n\ntry {\n  // Don't use node: prefix for this, require+node: is not supported until node v14.14\n  // Only `import()` can use prefix in 12.20 and later\n  const { Blob } = require('buffer')\n  if (Blob && !Blob.prototype.stream) {\n    Blob.prototype.stream = function name (params) {\n      let position = 0\n      const blob = this\n\n      return new ReadableStream({\n        type: 'bytes',\n        async pull (ctrl) {\n          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))\n          const buffer = await chunk.arrayBuffer()\n          position += buffer.byteLength\n          ctrl.enqueue(new Uint8Array(buffer))\n\n          if (position === blob.size) {\n            ctrl.close()\n          }\n        }\n      })\n    }\n  }\n} catch (error) {}\n/* c8 ignore end */\n","/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n","import Blob from './index.js'\n\nconst _File = class File extends Blob {\n  #lastModified = 0\n  #name = ''\n\n  /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */// @ts-ignore\n  constructor (fileBits, fileName, options = {}) {\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)\n    }\n    super(fileBits, options)\n\n    if (options === null) options = {}\n\n    // Simulate WebIDL type casting for NaN value in lastModified option.\n    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)\n    if (!Number.isNaN(lastModified)) {\n      this.#lastModified = lastModified\n    }\n\n    this.#name = String(fileName)\n  }\n\n  get name () {\n    return this.#name\n  }\n\n  get lastModified () {\n    return this.#lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return !!object && object instanceof Blob &&\n      /^(File)$/.test(object[Symbol.toStringTag])\n  }\n}\n\n/** @type {typeof globalThis.File} */// @ts-ignore\nexport const File = _File\nexport default File\n","/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\nimport C from 'fetch-blob'\nimport F from 'fetch-blob/file.js'\n\nvar {toStringTag:t,iterator:i,hasInstance:h}=Symbol,\nr=Math.random,\nm='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),\nf=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new F([b],c,b):b]:[a,b+'']),\ne=(c,f)=>(f?c:c.replace(/\\r?\\n|\\r/g,'\\r\\n')).replace(/\\n/g,'%0A').replace(/\\r/g,'%0D').replace(/\"/g,'%22'),\nx=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}}\n\nexport const File = F\n\n/** @type {typeof globalThis.FormData} */\nexport const FormData = class FormData {\n#d=[];\nconstructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}\nget [t]() {return 'FormData'}\n[i](){return this.entries()}\nstatic [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}\nappend(...a){x('append',arguments,2);this.#d.push(f(...a))}\ndelete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a)}\nget(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}\ngetAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}\nhas(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}\nforEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this)}\nset(...a){x('set',arguments,2);var b=[],c=!0;a=f(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d)});c&&b.push(a);this.#d=b}\n*entries(){yield*this.#d}\n*keys(){for(var[a]of this)yield a}\n*values(){for(var[,a]of this)yield a}}\n\n/** @param {FormData} F */\nexport function formDataToBlob (F,B=C){\nvar b=`${r()}${r()}`.replace(/\\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\\r\\nContent-Disposition: form-data; name=\"`\nF.forEach((v,n)=>typeof v=='string'\n?c.push(p+e(n)+`\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, '\\r\\n')}\\r\\n`)\n:c.push(p+e(n)+`\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type||\"application/octet-stream\"}\\r\\n\\r\\n`, v, '\\r\\n'))\nc.push(`--${b}--`)\nreturn new B(c,{type:\"multipart/form-data; boundary=\"+b})}\n","/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\nif (!globalThis.DOMException) {\n  try {\n    const { MessageChannel } = require('worker_threads'),\n    port = new MessageChannel().port1,\n    ab = new ArrayBuffer()\n    port.postMessage(ab, [ab, ab])\n  } catch (err) {\n    err.constructor.name === 'DOMException' && (\n      globalThis.DOMException = err.constructor\n    )\n  }\n}\n\nmodule.exports = globalThis.DOMException\n","import { statSync, createReadStream, promises as fs } from 'node:fs'\nimport { basename } from 'node:path'\nimport DOMException from 'node-domexception'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat } = fs\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs } = await stat(this.#path)\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nexport default blobFromSync\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync }\n"],"names":["queueMicrotask","streamBrandCheckException","defaultControllerBrandCheckException"],"mappings":"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","ignoreList":[44,45,46,47,48,49]}